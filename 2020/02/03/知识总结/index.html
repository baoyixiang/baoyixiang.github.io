<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习Java开发,SpringBoot进行Web开发"><title>知识总结（持续更新。。。） | 一路向前</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">知识总结（持续更新。。。）</h1><a id="logo" href="/.">一路向前</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">知识总结（持续更新。。。）</h1><div class="post-meta">Feb 3, 2020</div><div class="post-content"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="多线程和高并发"><a href="#多线程和高并发" class="headerlink" title="多线程和高并发"></a>多线程和高并发</h1><h2 id="1-谈谈-volatile-关键字"><a href="#1-谈谈-volatile-关键字" class="headerlink" title="1. 谈谈 volatile 关键字"></a>1. 谈谈 volatile 关键字</h2><p>首先说一下JMM，JAVA内存模型，一般来说，主内存是只内存，工作内存是指缓存Cache，一个处理器处理一个线程，这个处理器的Cache就是这个线程的工作内存，根据JMM规范，应该要保证<strong>可见性、原子性、有序性</strong>。</p>
<p>而volatile关键字可以保证可见性和有序性，并不能保证原子性</p>
<ul>
<li><p><strong>保持可见性</strong></p>
<p>主内存是线程共享的，工作内存是线程独立的，一个线程要操作主内存的数据，先从主内存的数据拷贝回自己的工作内存再进行操作，再写回到主内存。这样别的线程并不知道这个变量已经改了。保持可见性的意思就是当一个线程已经修改了主内存的变量的值，其他的线程能够立马收到最新消息。</p>
<p>那么是如何保持可见性的呢？首先修改变量线程的CPU在修改完变量后，不仅仅只写入对应的Cache，还会同时回写到主内存中，这样主内存中的值一直都是最新的，那如何保证其他线程的变量也是最新的呢？根据缓存一致性原则，当一个CPU写了变量，会通知其他CPU对应的缓存行失效，当其他CPU使用此变量的时候，会发现缓存行已经失效，就会从主内存中刷新变量</p>
<p>在汇编的层次，是在add命令之前加了个lock命令，这会使得lock后面的写操作，立即回写到主内存，同时使得<strong>总线上</strong>其他CPU的缓存行失效。这个是“嗅探”原理，即所有的CPU共享一条总线，数据交换都是通过这条总线，所以一个CPU修改数据，其他缓存能够“嗅探”到。另外，一个缓存行有状态标记，嗅探到了，使标记为无效即可。</p>
<p>参考文章（非常深入）：<a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="noopener">深入理解Volatile关键字及其实现原理</a></p>
</li>
</ul>
<ul>
<li><p><strong>禁止指令重排</strong></p>
<p>在单线程下，指令重排是不会影响数据的最终一致性的，但是在多线程下，指令重排就会影响，下面给个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只有一个线程，那么 a = 2  和 flag = true 这两条语句的顺序颠倒是不会影响 method2中的打印结果的。因为一个线程顺序执行method1和method2。当在多线程环境下，线程A执行method1，线程B执行method2，如果 a = 2 和 flag = true 的顺序变了，当 线程A的flag = true 执行完之后，线程B进来了，这个时候线程B的打印结果是 0 而不是 2。</p>
<p>再看一个案例，是双重检验单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 加锁之后，即使某个线程获取时 instance 不为空，也会阻塞在这，所以要再加一个判断</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 如果这里不加锁的话，两个线程同时判断时，会都为空</span></span><br><span class="line">                <span class="comment">// 两个线程获得的实例并不是单例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，instance 要用volatile修饰，因为 <code>instance = new Singleton()</code> 分三步：</p>
<ol>
<li>在堆内存中给实例分配空间</li>
<li>初始化这个实例</li>
<li>将实例对象的地址赋值给instance变量</li>
</ol>
<p>如果不禁止指令重排，第三步有可能会在第二步之前执行，这个时候，instance并不为空，会直接返回一个未初始化完成的实例对象。</p>
</li>
</ul>
<ul>
<li><p><strong>不能保证原子性</strong></p>
<p>最常见的一个例子就是 i++ 自增操作，自增操作不是原子操作，分为三步：</p>
<ol>
<li>从缓存中获取变量 i</li>
<li>自增 i</li>
<li>回写到缓存中</li>
</ol>
<p>当两个线程A，B同时进行i++操作时，先同时对缓存中读取 i，然后进行 +1 操作，即使变量i进行了volatile修饰，A线程通知了B线程缓存行失效，<strong>但是B此时已经不需要读这个缓存行了，刷新的前提是读缓存行时发现失效了</strong>，这个时候A和B都会回写到主内存中，发生了覆盖。（要知道，原子操作还是很少的，所以volatile的作用还是很有限的）</p>
<p>如何解决呢？ 1. 加synchronize锁，2. 用AtomicInteger（CAS操作保证原子性）</p>
</li>
</ul>
<h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h2><p>CAS的意义就是比较并交换，即只有当我们的预期值没有被修改时，才去修改变量，先看看 AtomicInteger 是如果利用CAS来保证 i++ 会造成的写覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger <span class="keyword">int</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span>.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>); </span><br><span class="line"><span class="comment">// 当第一个线程想要将新值 2019 写回主内存的时候，期望主内存的值是5，才将值更新为2019</span></span><br><span class="line"><span class="comment">// 第一个线程成功之后，第二个线程再执行这条语句就会失败，这样就避免了 写覆盖</span></span><br><span class="line"><span class="comment">// 当然这里的5肯定不是这样直接给的，在接下来的源码中会分析到。</span></span><br></pre></td></tr></table></figure>

<p>先看看AtomicInteger的自增方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unsafe 类是为了提高JAVA的效率，因为java不能操作底层，unsafe类使得java可以向c语言一样使用指针来操作内存，因为unsafe类中的方法基本都是native修饰的，在底层则是用c语言实现的。我们可以看到参数有 <code>this</code> 和<code>valueOffset</code>, 通过这两个可以得到这个变量在内存中的真实地址。同时，unsafe类中的compareAndSwap方法是原语操作，保证了原子性。</p>
<p>我们接着往下看，这段代码是核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var1是AtomicInteger实例的首地址，var2是value的偏移地址</span></span><br><span class="line">        <span class="comment">// 通过这条语句，可以得到主内存中的 value 的值</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这这个间隙，其他的线程可能会修改掉主内存的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// while中的语句就是unsafe类中的语句，是原子语句，执行时不会再发生写覆盖</span></span><br><span class="line">        <span class="comment">// 其意思就是，根据var1和var2获取到主内存中的值，如果这个值还是var5，</span></span><br><span class="line">        <span class="comment">// 说明没有被其他的线程修改，我这个线程就可以直接修改</span></span><br><span class="line">        <span class="comment">// 如果不为var5了，说明被其他线程修改了，就不能修改，回到循环体中</span></span><br><span class="line">        <span class="comment">// 当回到循环体中后，由于value是被volatile修饰过的（必须的），</span></span><br><span class="line">        <span class="comment">// 所以获得到的var5是最新的别人修改过的。</span></span><br><span class="line">        <span class="comment">// 然后再进行一次这样的判断。</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我理解的本质就是，不用CAS时，线程修改数据，有从主内存取得数据、修改数据、回写数据这三步，在回写数据这一步，可能主内存已经被别的线程回写过了，就会发生回写覆盖。为了解决这个，CAS在回写的时候会<strong>将主内存与自己工作内存之前取得的值比较一下</strong>，就可以判断出是否已经被别人修改过了，如果没有，我就可以修改，不过别人修改过了，我再去一次，在最新的值上面再修改。</p>
<p>那么为什么用CAS而不用Synchronized锁呢，要知道，加锁之后，最耗时的就是线程的上下文交换，也就是线程被挂起和被唤醒的过程，在这个过程中，操作系统会在核态和用户态之间切换，要保存运行环境和回复运行环境，这些都是很费事的，在JAVA1.6之后优化的自旋锁就是为了避免上下文交换。通过上面的分析可以看到，do，while循环也避免了线程的上下文交换，性能会高很多。</p>
<p>最后再讲一下CAS的缺点</p>
<ol>
<li>首先虽然CAS没有挂起线程，增加了并发性，但是当很多个线程进行自旋，就会白白耗费CPU资源，这种并发，就只是让很多线程在那循环等待。</li>
<li>只能保证一个共享变量的原子操作。CAS要有一个compare，一个变量就好比对，如果是段代码，一个类呢？synchronized就能锁这样的，当时还有AtomicReference等类有相应的操作。</li>
<li>ABA问题，会在下一节详细讲一下ABA问题</li>
</ol>
<h2 id="3-CAS中的ABA的问题"><a href="#3-CAS中的ABA的问题" class="headerlink" title="3. CAS中的ABA的问题"></a>3. CAS中的ABA的问题</h2><p>先有两个线程，其中一个线程运行的比较快，将主内存中的变量从 A 改成了 B， 再从 B 改成了 A，这个时候，另外一个线程调用 compareAndSwap方法时，会发现期望值与实际值是相同的，它并不知道中间已经被修改过了，它就会修改掉这个值。</p>
<p>当我们的实际问题不能容忍这个被修改的过程，这个问题就很严重了，比如会员卡的问题，用户消费20元，紧接着再充值20元，如果积分统计线程是根据余额的减少来统计积分的，那就严重了，积分统计线程并不知道用户已经消费过了，积分没统计上，这是一个大漏洞。</p>
<p>那怎么解决呢？在加个变量（时间戳）来标识这个变量是否被修改过了。这样下来，在执行 compareAndSet() 方法的时候，不仅仅比较变量是否相等，还要比较时间戳是否相等。AtomicStampReference类则实现了这个功能，我们看一下构造函数和对应的 compareAndSet() 方法的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference(V initialRef, <span class="keyword">int</span> initialStamp)</span><br><span class="line">compareAndSet(V expectedReference, V newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span><br></pre></td></tr></table></figure>

<p>在实际使用的时候，<code>newStamp</code> 的设置是手动的，我们一定要每次设置都是递增以保证不会跟之前的重复，否则时间戳也会出现ABA问题。</p>
<h2 id="4-线程安全的集合类"><a href="#4-线程安全的集合类" class="headerlink" title="4. 线程安全的集合类"></a>4. 线程安全的集合类</h2><p>这一节包括下一节的 JUC 中线程安全的容器在这里有总结：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">并发容器总结</a></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>先看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时会报 <code>java.util.ConcurrentModificationException</code> 错误。先讲一个为什么会出现这个问题。这是java集合类遍历时的fast-fail机制。</p>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4><p>fast-fail机制总结一下就是集合的iterator在遍历的时候会判断这个集合是否被其他线程修改过，如果被修改过，就抛出这个错误，提示用户现在出现了并发错误。</p>
<p>打印arrayList的时候会调用其 toString() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这就是集合的iterator遍历，我们再看看 next() 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在第一句，其作用就是，在一个线程遍历集合的过程中，每次获取下一个值之前都要先看看这个集合是不是被别的线程修改过，如果修改过，就抛出 <code>ConcurrentModificationException</code> 错误。我们再看看这个方法的源码就清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 modCount 和 expectedModCount 又是什么呢，这个跟 CAS 的思想有点像，即比较的思想。当一个线程获取的iterator时，<strong>会new一个新的iterator出来，expectedModCount是iterator的私有遍历，所以是线程私有的，在初始时，expectedModCount = modCount，</strong>在进行写操作时，比如add操作，就会 modCount++, 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法是 add方法调用的一个方法，可以看到进行了 modCount++</span></span><br><span class="line">    <span class="comment">// modCount 是共享变量。</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当另外一个线程添加了一个元素，遍历的线程调用next()的时候，会发现这个线程私有的 expectedModCount 与 线程共享的 modCount 不相等，就会抛出错误。</p>
<p>还有一种情况，即使在单线程下也会报这个错误，就是在遍历的过程中修改了这个集合，因为修改的时候只改变了modCount，没有改变 expectedModCount，造成了两者不一致。那么如何避免呢？即禁止在用iterator遍历的时候调用add、delete等写操作修改集合，而应该调用iterator<strong>的相应方法</strong>，为什么呢？我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);  <span class="comment">// 这个方法会修改modCount</span></span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;    <span class="comment">// 在这里同时也会修改 expectedModCount变量。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我再提个问，那么多线程的时候我们也用iterator对应的add方法可以吗？ 不行哦，别忘了，iterator是线程私有的，也就是说语句 <code>expectedModCount = modCount</code>  修改的 expectedModCount 只是修改了自己线程的 expectedModCount变量。所以唯一的解决方法就是写写加锁。</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>再说在并发情况下如何避免这个问题：</p>
<ol>
<li>用Vector，但是我们知道，Vector是暴力加锁，会降低性能，而且Vector也被废弃了</li>
<li>用Collections.synchorinzedList()方法包裹一些，这样也是暴力加锁</li>
<li>用 JUC 包中的 <code>CopyOnWriteArrayList</code> , 它是线程安全的list，只有在写写的时候会加锁，性能好很多。</li>
</ol>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>接下来讲讲 CopyOnWriteArrayList 的原理。看懂 add() 方法的源码就大概知道了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();   <span class="comment">// 获取原本的 array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">// 将 array 复制一份</span></span><br><span class="line">        newElements[len] = e; <span class="comment">// 修改复制后的array</span></span><br><span class="line">        setArray(newElements); <span class="comment">// 将修改后的array赋值给原本的array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CopyOnWriteArrayList的写操作并不是修改原本的array，而是复制一份进行修改。同时也加了锁，在多线程的情况下不会复制出多个副本。其读操作是没有加任何锁的，直接返回原本的 array。</p>
<p>为什么要复制呢？这是我写这部分时的一个问题，答案是为了读写分离，也就是为了在写的时候读操作不阻塞也能不出问题，先来分析一下，为什么如果写原数组时，不阻塞读操作会出错？因为读和写操作都不是原子操作，他们可能会交替执行。比如我们把上述代码改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();   <span class="comment">// 获取原本的 array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        len = len + <span class="number">1</span></span><br><span class="line">        elements[len] = e; <span class="comment">// 修改复制后的array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程执行到 <code>len = len + 1</code> 的时候，另外一个线程来进行读操作了，比如执行 <code>getLast()</code> 方法，即执行<code>get(len - 1)</code>, 但是现在这个位置是没有赋值上的，就出现了问题。但是如果修改时是复制一份来修改，另外一个线程读的时候就没有任何影响。这也就是为什么在没有这个容器之前，只能做到读读不加锁，读写，写读和写写都要加锁。有了这个容器，就可以只在写写的时候加锁了。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 同样也是线程不安全的，那如何避免呢？当然有一种是 <code>Collections.synchornizedSet()</code> 来加锁，这不是一个好的方法，好的解决方法是 CopyOnWriteArraySet。其原理非常简单，其源码也很少，因为它是基于CopyOnWriteArrayList 的，它内部有个 CopyOnWriteArrayList 变量，对其的操作都是操作的这个变量。比如add方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>当然也是不安全的，一种方法是用<code>Conllections.synchronizes()</code>方法加锁，更好的解决办法就是用JUC包中的 ConcurrentHashMap。</p>
<p><strong>ConcurrentHashMap：</strong></p>
<p>这里先简单的介绍一下，这一部分后续可能会研究一下源代码</p>
<ul>
<li><strong>底层数据结构</strong>：在JDK1.7的时候，ConcurrentHashMap用的是 <strong>分组的数组 + 链表</strong> 的方式，JDK1.8用的是跟HashMap一样的结构，即 <strong>数组 + 链表 / 红黑树</strong>。</li>
<li><strong>实现线程安全的方式</strong>：在JDK1.7的时候，使用的分段锁，它会把数组分成多个段(Segment)，每次加锁只在其中一个段上加锁，其余段上的线程不会阻塞，提高了并发量。在JDK1.8之后则直接使用了Synchronized + CAS的方法来实现线程安全。<strong>在用hash定位到数组的头节点时，如果没有发生冲突就用CAS来实现写操作的线程安全，如果发生了冲突，则锁住这个头节点。</strong></li>
</ul>
<h2 id="5-线程安全的队列"><a href="#5-线程安全的队列" class="headerlink" title="5. 线程安全的队列"></a>5. 线程安全的队列</h2><p>队列分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，阻塞队列是通过<strong>加锁</strong>实现的，非阻塞队列是通过<strong>CAS操作</strong>实现的。非阻塞队列只有一个，就是<code>ConcurrentLinkedQueue</code>，它是一个<strong>无界</strong>的安全队列，入队和出队都是用的 CAS 操作来保证线程安全性。那么为什么要用阻塞队列呢？阻塞听起来就不是个好词，因为阻塞队列可以做到，<strong>线程在向一个队满的队列插入数据时会阻塞挂起，在从一个对空的队列取数据时也会阻塞挂起，等到合适的时间再唤醒，继续执行</strong>，这就是阻塞的意思，同时，在进行写操作时，加了 <strong>ReentrantLock</strong> 来保证线程安全。而<strong>线程在从一个空的非阻塞队列中取数据时会直接取出null，执行完成</strong>，这在有时候是不符合实际业务的，比如生产者消费者模式，还有消息队列（恰恰，消息队列底层数据结构就是阻塞队列）。</p>
<p>关于阻塞队列，这篇文章非常详细：<strong><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">解读 java 并发队列 BlockingQueue</a></strong>，阻塞队列都是实现了 <code>BlockingQueue</code>接口，有如下7个：</p>
<ul>
<li><strong><code>ArrayBlockingQueue</code> ：由数组组成的有界阻塞队列</strong></li>
<li><strong><code>LinkedBlockingQueue</code>：由链表组成的有界（但默认大小为Integer.MAX_VALUE）阻塞队列</strong></li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li>
<li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列</li>
<li><strong><code>SynchronousQueue</code>：不存储元素的阻塞队列，即单个元素的队列</strong></li>
<li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列</li>
<li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">限时阻塞</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center"><strong>put(e)</strong></td>
<td align="center">offer(e, time, util)</td>
</tr>
<tr>
<td>移出</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center"><strong>take()</strong></td>
<td align="center">poll(time, util)</td>
</tr>
<tr>
<td>检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td>备注</td>
<td align="center">即在队满或者队空的时候，调用这三个方法会抛出异常</td>
<td align="center">即在队满的时候调用offer(e)直接返回false，元素不入队，在对空的时候调用 poll()和peek() 则返回null。</td>
<td align="center">在队满的时候调用put(e)和在队空的时候调用 take() 都会阻塞线程。<strong>常用的，因为这一对涉及到阻塞</strong></td>
<td align="center">可以设置<strong>阻塞的时间</strong>，当有这个需求的时候可以用这个</td>
</tr>
</tbody></table>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>看这篇文章：<strong><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">解读 java 并发队列 BlockingQueue</a></strong>，干货。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>生产者消费者模式：有了阻塞队列，我们实现生产者消费者模式只需要调用接口就行了，不用自己实现线程的阻塞和唤醒，也就是说阻塞队列接口的实现方式就是生产者消费者模式的实现。再之后会详细讲述生产者消费者模式</li>
<li>线程池：线程池的底层也是用到了阻塞队列，其实它的本质也是生产者消费者模式，只不过这里的资源是<strong>线程</strong></li>
<li>消息中间件：RabbitMQ等消息队列的底层数据结构就是用到了阻塞队列，因为它的模型也是生产者消费者模式。</li>
</ul>
<h2 id="6-各种锁"><a href="#6-各种锁" class="headerlink" title="6. 各种锁"></a>6. 各种锁</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁就是获取锁的顺序就是申请锁的顺序，即先来后到。非公平锁则不一定，即可以加塞，在多线程的情况下，可能会造成<strong>优先级反转和饥饿现象</strong>。在JAVA中，<strong>ReentrantLock、ReadWriteLock、Synchronized</strong>默认都是非公平模式。非公平锁的吞吐量比公平锁高，性能也好一些。</p>
<p>公平锁与非公平锁在实现机制上的具体区别就是：公平锁在获取锁之前会先判断等待队列是否为空或者自己位于队列首部，如果为true则可以继续获取锁，否则就入队等待。而非公平锁则直接去获取锁，这就导致，如果锁刚刚释放的时候来了一个线程获取非公平锁，而等待队列中的线程还没来得及去获取，等到它去获取的时候，这个锁以及被占了。我们分别看看ReentrantLock中的公平锁和非公平锁中的获取锁的代码：</p>
<p>首先是非公平锁，可以看到，<strong>获取锁的时候直接去获取的</strong>，<code>compareAndSetState(0, 1)</code> 修改锁的状态，修改成功则表示锁已经被释放了，然后把占有锁的线程改为本线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看公平锁，对比一下看到非公平锁可以说是非常暴力的去占有了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 状态为0说明锁已经释放了，就可以去试着获取锁了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 再尝试获取之前（即修改锁的状态）还调用了hasQueuedPredecessors()，这是公平锁实现的核心逻辑</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 这个是可重入锁的逻辑，如果此线程已经获取锁了，还可以获取锁（可能锁的不是同一个地方）</span></span><br><span class="line">        <span class="comment">// acquires变量就是这个锁被获取的次数了。</span></span><br><span class="line">        <span class="comment">// 再获取 +1 即可</span></span><br><span class="line">        <span class="comment">// 别的线程获取锁的时候也要等到获取的锁全部释放了才行</span></span><br><span class="line">        <span class="comment">// 因为调用的是 compareAndSetState(0, 1), 0是期望值，也就是acquires为0才行</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深入看看 <code>hasQueuedPredecessors()</code>，作用是判断此线程是否应该放入等待队列。 首先说明一下这个等待队列是个头节点不存元素的队列。<code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</code> 表示<strong>此队列不为空并且这个线程不在头节点处</strong>，就应该入等待队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁（又名递归锁）"><a href="#可重入锁（又名递归锁）" class="headerlink" title="可重入锁（又名递归锁）"></a>可重入锁（又名递归锁）</h3><p>可重入锁的意思就是，外层方法获得锁之后，进入内层方法调用的方法自动获得，并不会阻塞。直接点的意思就是，同一个线程，可以多次获得同一把可重入锁，写一个例子看看，再结合上一节公平锁中 <code>tryAcquire()</code> 中的注释，就能理解的比较清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 多线程共享变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doSomething();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>print()</code> 方法的同步块中，调用 <code>dosomething()</code> 方法时又获取了这把锁，这个时候这把锁还没有释放，也就是上一节中的代码中的 state 并不为 0，但由于是可重入锁，所以并不会阻塞，而是将 acquires 变量 +1。注意可重入锁的可重入性只针对本线程。</p>
<p>为什么要用到可重入锁呢？就是我们想锁的代码块只不想别的线程同时执行，但是本线程的同步块还是可以调用执行的。比如上述例子，<code>doSomething()</code> 方法在多线程下可能会出现并发问题，<code>print()</code> 同样，所以我们都得锁上，但是 <code>print()</code> 方法中调用了 <code>doSomething()</code> 方法，如果不可重入，这个线程就被自己锁死在这了。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>JDK1.6 对锁的实现引入了大量的优化，包括偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等。<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">具体介绍</a>，还有深入理解JVM一书。</p>
<p>首先先主要介绍一些自旋锁。简单一句就是，<strong>如果获取不到锁，此线程并不挂起，而是循环获取锁，一直到获取到为止。</strong>为什么要这样呢？锁对性能的消耗就在于线程挂起和唤起的上下文切换，操作系统要在核态和用户态之间切换，很费时。<strong>它的缺点就是在竞争很激烈的情况下会有很多线程一直循环，占用资源。</strong></p>
<p>自旋锁的应用就是 CAS 操作 + 循环，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;Thread&gt; atomicThread = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (atomicThread.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p><strong>独占锁</strong>就是同一时间只能有一个线程持有，ReentrantLock 和 Synchronized 都是独占锁。<strong>共享锁</strong>就是同一时间可以有多个线程持有。</p>
<p>ReentrantReadWriteLock为读写锁，对于读操作是共享锁，对于写操作是独占锁。这样可以做到<strong>读读操作不互斥</strong>，但是读写，写读和写写操作都是互斥的。提一下之前提到的 CopyOnWriteArrayList，对它的操作可以只做到写写互斥，其余三个操作不互斥。</p>
<p><code>ReentrantReadWriteLock</code> 分为 <code>writeLock</code> 和 <code>readLock</code> 两种锁，下面是读写锁的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            count ++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Main resource = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(resource::writeOperation, <span class="string">"t"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">110</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(resource::readOperation, <span class="string">"t"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果运行的效果是：先每隔 一秒打印一次 <strong>ti</strong>，说明写写互斥（每隔1s打印），写读互斥（打印时不输出读操作的输出），如果把两个循环交换顺序，可以看到，程序先等一秒，然后一次性输出十次数据，接着再一秒一次打印 <strong>ti</strong>， 说明读读不互斥（一次性全输出），读写互斥（读操作的sleep 1s的过程中，并没有输出写操作的输出）。</p>
<h2 id="7-CountDownLatch-CyclicBarrier-Semaphore"><a href="#7-CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="7. CountDownLatch / CyclicBarrier / Semaphore"></a>7. CountDownLatch / CyclicBarrier / Semaphore</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>就是个计数器，要等计数器为 0 之后才能继续往下执行，方法就几个，用起来比较简单，直接看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(countDownLatch::countDown).start();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 会在这阻塞，直到计数变为0</span></span><br><span class="line">    countDownLatch.await(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>跟 CountDownLatch 相反，CyclicBarrier 设置一个屏障，当要求个数的线程到齐了才能执行，之前到的会一直阻塞在这。例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数中的 Runnable 会在阻塞了六个线程之后执行。</span></span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">6</span>, () -&gt; System.out.println(<span class="string">"来完了"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"来一个"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 会阻塞在这</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果把语句 System.out.println("来一个"); 放在这，会在 6s 之后跟参数中的Runnable一起执行。</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>在资源有多个的时候，可以用 Semaphore 来进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享资源有3个</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();  <span class="comment">// 抢占资源, 还可以通过参数控制获取的资源数</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"抢到资源"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                semaphore.release(); <span class="comment">// 释放资源，可以通过参数控制释放的资源数</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Synchronized-与-Lock-的区别"><a href="#8-Synchronized-与-Lock-的区别" class="headerlink" title="8. Synchronized 与 Lock 的区别"></a>8. Synchronized 与 Lock 的区别</h2><ol>
<li><p>Synchronized 是属于虚拟机层面，Lock是属于api层面，前者是关键字，后者是java实现的类。也就是说前者是在<strong>JVM内部</strong>实现的，Lock是在<strong>语言层面</strong>实现的。JVM内部使用的是 monitorenter 和 monitorexit 指令实现，Lock基本的是用的 state 变量来判断是否被锁。</p>
</li>
<li><p>Synchronized 不用手动释放锁，代码执行完了自动释放，而Lock要手动释放，lock() 和 unlock() 方法必须配对使用。</p>
</li>
<li><p>Synchronized 不能中断，必须抛出异常或者代码执行完，</p>
<p>而 Lock 可以中断，这也是Lock的特点。1. 可以设置超时方法 <code>tryLock(long timeout, TimeUnit unit)</code>; 2. 上锁的时候可以上可中断锁 <code>lockInterruptibly()</code> ，线程阻塞在锁这的时候可以在其他线程中调用 <code>interrupter()</code> 方法中断，抛出 <code>InterruptedException</code> 异常以供处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"被中断了"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    Thread th = <span class="keyword">new</span> Thread(resource::method);</span><br><span class="line">    th.start();</span><br><span class="line">    Thread th1 = <span class="keyword">new</span> Thread(resource::method, <span class="string">"tttttt"</span>);</span><br><span class="line">    th1.start();</span><br><span class="line">    th1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Synchronized 是非公平锁，Lock默认是非公平锁，但是可以设置成公平锁。</p>
</li>
<li><p>Synchronized 唤醒线程时只能随机唤醒，Lock可以搭配Condition实现精准唤醒某个线程。<strong>通过声明多个 Condition 来实现，唤醒时唤醒阻塞在某个 Condition 上的线程。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> who = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (who != <span class="number">1</span>) </span><br><span class="line">                c1.await();</span><br><span class="line">            System.out.println(<span class="string">"11111111111111"</span>);</span><br><span class="line">            who = <span class="number">2</span>;</span><br><span class="line">            c2.signal(); <span class="comment">// 精准唤起阻塞在 print2 方法中的线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (who != <span class="number">2</span>)</span><br><span class="line">                c2.await();</span><br><span class="line">            System.out.println(<span class="string">"222222222222222"</span>);</span><br><span class="line">            who = <span class="number">1</span>;</span><br><span class="line">            c1.signal(); <span class="comment">// 精准唤起阻塞在print1中的线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::print1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::print2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="9-生产者消费者模式"><a href="#9-生产者消费者模式" class="headerlink" title="9. 生产者消费者模式"></a>9. 生产者消费者模式</h2><p>自己手撸一个简易版的生产者消费者模式，我们需要自己判断线程什么时候应该阻塞，要怎么阻塞，什么时候应该唤醒，应该怎么唤醒，这些需要用到 <code>ReentrantLock</code> 来加锁，还要用到 <code>Condition</code> 的 <code>await()</code> 和 <code>signal()</code> 方法来控制线程的阻塞和唤醒。</p>
<p>当有了阻塞队列之后，我们就不用自己控制这些了，使得开发更加便捷，但是通过自己实现简易版的生产者消费者模式我们可以了解到阻塞队列的原理，阻塞队列内部也是通过<code>ReentrantLock</code> 来加锁，用<code>Condition</code>来控制线程的阻塞和唤醒的。</p>
<h3 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt;= capacity) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"阻塞在这了"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"被唤醒了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产了一个资源"</span> + <span class="string">"  "</span> + count);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"阻塞在这了"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"被唤醒了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"消费了一个资源"</span> + <span class="string">"  "</span> + count);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::produce, <span class="string">"生产者t"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::consume, <span class="string">"消费者t"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程中的判断一定要用 <strong>while</strong> 判断，而不能只用 if 判断，因为 <strong>await 操作阻塞线程会释放锁</strong>，这样的话，可能会有多个线程阻塞着，调用 signalAll 唤醒所有阻塞线程的时候，它们没有判断就直接执行操作，比如第一个生产者生产了一个资源，紧接着其余四个生产者阻塞在这，当一个消费者消费之后，这四个生成着都会一个一个接着生产，这样就会超出capacity。</p>
<h3 id="阻塞队列版"><a href="#阻塞队列版" class="headerlink" title="阻塞队列版"></a>阻塞队列版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>; <span class="comment">// 是否生产的标志</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger data = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 资源数据</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">null</span>; <span class="comment">// 通过消息队列来实现生产者消费者模式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        System.out.println(queue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> offerResult;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            <span class="comment">// 进队即表示生产, 两秒之后队列还是满的，就不等了</span></span><br><span class="line">            offerResult = queue.offer(data.incrementAndGet(), <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (offerResult) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者 "</span> + Thread.currentThread().getName() + <span class="string">" 生产成功："</span> + data.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者 "</span> + Thread.currentThread().getName() + <span class="string">" 等了2s队列仍为满，本次生产失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 1s后再生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"生产者被叫停了，停止生产"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer result;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = queue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者 "</span> + Thread.currentThread().getName() + <span class="string">" 等了2s队列任为空，停止消费"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者 "</span> + Thread.currentThread().getName() + <span class="string">" 消费成功："</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"停止生产和消费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    MySource mySource = <span class="keyword">new</span> MySource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"生产者启动"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mySource.produce();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"prod"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者启动"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mySource.consume();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"cons"</span>).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    mySource.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用阻塞队列来实现生产者和消费者模式，最大的一个好处就是我们<strong>不用自己去管理线程的阻塞和唤醒</strong>。</p>
<h2 id="10-Callable"><a href="#10-Callable" class="headerlink" title="10. Callable"></a>10. Callable</h2><p><code>Callable</code> 和 <code>Runnable</code> 的主要区别就是 <code>Callable</code> <strong>有返回值，并且可以在发生错误时抛出异常</strong>，在需要有返回值或者需要在多线程环境下进行排错时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何使用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread1());        </span><br><span class="line"><span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure>

<p>为什么是这么用的呢，我们可以看到，<code>Thread</code> 类的构造函数中只有 <code>Runnable</code> ，没有 <code>Callable</code>，但是我们先看看下列的实现和继承关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在 <code>FutureTask</code> 中有一个成员变量为 <code>private Callable&lt;V&gt; callable;</code> ，也就是说，JDK对 <code>Runnable</code> 接口和 <code>Future</code>接口做了包装和实现，在调用的时候也能像 <code>Runnable</code>一样的去传参。而在调用 <code>run()</code> 方法的时候，实际上是调用了 <code>Callable</code> 的<code>call()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么要用 <code>Callable</code>呢，为什么有了 <code>Runnable</code> 还要用 <code>Callable</code> 呢？答案是异步，是减少阻塞，即主线程在执行到这个线程时，并不在这阻塞，而是继续往下执行，这个线程继续进行它的计算，在未来的某一时刻，我们在调用 <code>futureTaks.get()</code> 来获取结果，如果调用这个方法时，<strong>计算还没有完成，还是会阻塞</strong>，但是我们已经执行完我们想执行的操作啦，<strong>提高了并发，充分利用了CPU资源</strong>。如下代码看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 耗时计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Date begin = <span class="keyword">new</span> Date();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread1());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start(); <span class="comment">// 如果在此处阻塞进行线程中的耗时计算，理论上最后的输出为 3000以上。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"看看阻塞了没"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    Integer ele1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(futureTask.get() + ele1); <span class="comment">// 如果还没算完，仍然阻塞，但是上面三句语句已经执行了</span></span><br><span class="line">    Date end = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(end.getTime() - begin.getTime());  <span class="comment">// 输出为 2002，提高了并发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就又有一个疑问，就算是用 <code>Runnable</code> 执行，也是不回阻塞的呀？但是这里的情况是数据依赖的，我们的后续操作要用的数据，必须是计算完的结果，如果我们用 <code>Runnable</code>,  <strong>我们也必须控制线程的执行顺序，并且还要获取计算结果</strong>，是很麻烦的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="number">1</span>;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Date begin = <span class="keyword">new</span> Date();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"看看阻塞了没"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    Integer ele1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    thread.join(); <span class="comment">// 用它来控制数据依赖时线程的执行顺序</span></span><br><span class="line">    System.out.println(data + ele1);</span><br><span class="line">    Date end = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(end.getTime() - begin.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable</code> 还有很多优点，比如<strong>同一个 <code>Callable</code> 线程</strong>，多次调用 <code>start()</code> 方法时，<strong>只会调用一次</strong>，因为结果已经算出来了。<code>Callable</code> 还实现了  <code>Future</code> 接口，提供了 <code>cancel()</code> 、<code>isCancelled()</code> 等方法，使用起来更灵活强大。</p>
<h2 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h2><h3 id="线程池的特点和优势"><a href="#线程池的特点和优势" class="headerlink" title="线程池的特点和优势"></a>线程池的特点和优势</h3><p>线程池中的线程，需要时直接分配，而不是新创建一个，不需要时归还给线程池，而不需要真的销毁。其最大的特定就是：<strong>线程复用、控制最大并发数、管理线程</strong></p>
<ol>
<li>线程的创建和销毁是很耗时间的，线程复用即可通过<strong>重复利用线程来降低此消耗</strong>。</li>
<li><strong>提高响应速度</strong>，任务来了可以不用等线程创建的过程。</li>
<li>线程本身也要占据内存空间的，如果使用不当，可能会导致OOM异常。即使没有，大量的线程回收也会加重GC回收线程的压力，所以我们要用线程池来<strong>控制最大并发数</strong>。</li>
<li><strong>提高线程的可管理性</strong>，通过线程池可以对线程进行统一的<strong>分配，调优和监控</strong>。</li>
</ol>
<h3 id="常用的线程池及其创建方式"><a href="#常用的线程池及其创建方式" class="headerlink" title="常用的线程池及其创建方式"></a>常用的线程池及其创建方式</h3><p>先说一下各个类的继承和实现的关系。<code>ThreadPoolExecutor</code> 是线程池的一个实现类，它实现了 <code>ExecutorService</code> 接口。<code>Executors</code> 是一个工具类，<strong>用来创建线程池的</strong>， 主要有以下工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>newFixedThreadPool</code> 返回一个固定数量的线程池，当有空闲线程时，将新任务分配给它，<strong>如果没有空闲线程，将任务暂存进任务队列中。</strong></li>
<li><code>newSingleThreadExecutor</code> 返回只有一个线程的线程池，如果没有空闲线程，将任务暂存进任务队列，当有空闲队列，<strong>按入队的顺序处理</strong>（与使用的任务队列有关）</li>
<li><code>newCachedThreadPool</code> 返回一个按实际情况调整的线程池，如果没有空闲线程，则新建线程。</li>
<li><code>newSingleThreadScheduledExecutor()</code> 只有一个线程，可以指定在某个延迟时间后执行，或者周期性执行。</li>
<li><code>newScheduledThreadPool</code> 可以指定线程数量。</li>
</ol>
<p>以下一个示例展示了如何使用线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor-的七大参数"><a href="#ThreadPoolExecutor-的七大参数" class="headerlink" title="ThreadPoolExecutor 的七大参数"></a>ThreadPoolExecutor 的七大参数</h3><p>上述创建线程池方法的前三个，其底层都是通过 <code>new</code> 一个 <code>ThreadPoolExecutor</code> 对象来实现的，如果这三种线程池不能满足我们的需求，我们就需要自己来创建了，<code>ThreadPoolExecutor</code> 为我们提供了七个参数，以供我们自定义。<strong>在阿里编码规范中，也禁止我们用 Executors 来创建线程池，因为有弊端，前两个是无界队列，后一个线程数最大为Max，都可能导致资源耗尽。并且，用 <code>ThreadPoolExecutor</code> 来创建线程池，我们会更加了解线程池的各个特点，避免浪费资源。当面试官问我们用哪个 <code>Executors</code> 的方法来创建，答案是一个都不用。</strong></p>
<p>先看看定制好的三种线程池的参数分别为什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再一一讲解这些参数的含义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：线程池中常驻的线程数量（可以用来工作的线程），当任务数超过这个数，任务会放到任务队列中。</li>
<li>maximumPoolSize：指定了线程池中最大的线程数量（任务量大于 corePoolSize时，可以再创建线程）</li>
<li>keepAliveTime：指定了多余空闲线程的存活时间，即超过 corePoolSize 的空闲线程，在多久之后会被销毁（在任务量降下来之后，之前创建的线程<strong>会慢慢销毁，节省资源</strong>）</li>
<li>unit：keepAliveTime的单位</li>
<li><strong>workQueue</strong>：任务队列，被提交但未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认</li>
<li><strong>handler</strong>：拒绝策略，表示当队列满了，并且<strong>工作线程</strong>大于等于 maximumPoolSize，如何拒绝任务。</li>
</ul>
<h3 id="各种阻塞队列的效果"><a href="#各种阻塞队列的效果" class="headerlink" title="各种阻塞队列的效果"></a>各种阻塞队列的效果</h3><ul>
<li><strong>SynchronousQueue</strong>：容量为0，提交的任务不会真实的保存，而总是将任务提交给线程执行，当没有空闲线程的时候，会创建新的线程来执行，如果线程数已经达到了 maximumPoolSize ，则会执行拒绝策略。</li>
<li><strong>ArrayBlockingQueue</strong>：<strong>有界队列</strong>，<strong>如果没有空闲线程（即工作线程数大于等于corePoolSize）</strong>，则会将任务暂存到此队列，如果队列满了，线程数小于 maximumPoolSize，则创建新的线程，否则，执行拒绝策略</li>
<li><strong>LinkedBlockingQueue</strong>：<strong>无界队列</strong>，<strong>如果没有空闲线程（即工作线程数大于等于corePoolSize）</strong>, 则会将任务暂存到此队列，队列不会满，所以线程池中的线程数不会大于 corePoolSize。使用无界队列要注意任务创建速度过快与处理速度时，内存资源耗尽。</li>
<li><strong>PriorityBlockingQueue</strong>：<strong>无界队列</strong>，区别在于，出队时是根据优先级来出队的。</li>
</ul>
<h3 id="线程池的底层原理"><a href="#线程池的底层原理" class="headerlink" title="线程池的底层原理"></a>线程池的底层原理</h3><p>流程如下：</p>
<ol>
<li>在创建了线程池之后，线程池等待任务的提交。</li>
<li>当调用 <code>executor()</code> 时，会做如下判断：<ol>
<li>正在执行的线程数小于 corePoolSize，分配空闲线程执行任务</li>
<li>正在执行的线程数大于等于 corePoolSize，任务进入等待队列</li>
<li>如果等待队列满了，并且正在执行的线程数小于 maximumPoolSize，创建新的线程执行任务。</li>
<li>如果等待队列满了，并且正在执行的线程数等于 maximumPoolSize，则执行拒绝策略</li>
</ol>
</li>
<li>当一个线程执行完一项任务，会从任务队列中取任务来执行。</li>
<li>当一个线程空闲时间超过 keepAliveTime 时，会进行判断：如果线程池中的线程（<strong>执行线程+空闲线程</strong>）数量大于 corePoolSize, 这个线程就会停掉，所以当任务量少下来之后，线程池中的线程数会慢慢回归到 corePoolSize。</li>
</ol>
<p>从 <code>excutor()</code> 的源码我们也大概能看出以上步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果执行线程小于 corePoolSize, 分配执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则加入等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 加入成功之后，线程池被 shutdown 了，就把这项任务移除了，移除成功之后再拒绝</span></span><br><span class="line">        <span class="comment">// 这部分不知为何这样设计，目前能理解步骤，但不知为何这样。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列满了，创建新线程进行执行，如果创建失败，说明执行线程达到了maximumPoolSize，则拒绝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h3><ul>
<li>AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常，阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行机制” 即只要线程池未关闭，则任务返回到<strong>调用者线程</strong>中，运行当前被丢弃的任务，例如我们在<strong>主线程中调用线程池的<code>execute()</code>，被拒绝的任务会在 主线程 中执行。</strong></li>
<li>DiscardOldestPolicy：丢弃等待最久的那个任务（即即将被执行的那个），相当于出队一次再入队一次。然后再次尝试提交当前任务。</li>
<li>DiscardPolicy：直接丢弃，不给予任何处理。</li>
</ul>
<h3 id="自定义线程池和拒绝策略"><a href="#自定义线程池和拒绝策略" class="headerlink" title="自定义线程池和拒绝策略"></a>自定义线程池和拒绝策略</h3><p>这部分，要了解 <code>ThreadPoolExecutor</code> 的七大参数，还要知道拒绝策略是如何自己实现的，上一节说到的四种拒绝策略都实现了 <code>RejectedExecutionHandler</code> 接口，此接口只有一个方法，<strong>我们重写一个类，实现此接口就可以了，因为参数都是接口，我们传入实现类即可，可扩展的精髓</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// r 是要执行的任务，executor 是执行任务的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">6L</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    (r, executor) -&gt; System.out.println(<span class="string">"丢弃了"</span> + r.toString())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的线程数量的确定"><a href="#线程池的线程数量的确定" class="headerlink" title="线程池的线程数量的确定"></a>线程池的线程数量的确定</h3><p>关于这个问题，我们要根据任务是 CPU 密集型还是 IO 密集型来分。</p>
<ol>
<li>CPU 密集型，持续性的占用CPU，所以我们要减少线程上下文切换，maximumPoolSize = cpu线程数 + 1</li>
<li>IO 密集型，并不是持续占用CPU，可以同时多执行点任务<ol>
<li>maximumPoolSize = cpu线程数 * 2</li>
<li>maximumPoolSize = cpu线程数  / (1 - 阻塞系数) ，其中阻塞系数在 0.8 到 0.9 之间（其中一种方案）</li>
</ol>
</li>
</ol>
<p>还有一种方案是《实战Java高并发程序设计》书中所给的：<strong>Nthreads = Ncpu * Ucpu * (1 + W/C)</strong></p>
<p>其中 <strong>Ncpu</strong> 为cpu的线程数，<strong>Ucpu</strong> 为期望cpu的使用率(0&lt;=Ucpu&lt;=1)，<strong>W/C</strong>为等待时间与计算时间的比率。</p>
<h1 id="面试题目总结"><a href="#面试题目总结" class="headerlink" title="面试题目总结"></a>面试题目总结</h1><h2 id="1-HashSet的底层是什么？（答HashMap，会问为什么hashSet-add-“a”-只有一个参数）"><a href="#1-HashSet的底层是什么？（答HashMap，会问为什么hashSet-add-“a”-只有一个参数）" class="headerlink" title="1. HashSet的底层是什么？（答HashMap，会问为什么hashSet.add(“a”)只有一个参数）"></a>1. HashSet的底层是什么？（答HashMap，会问为什么hashSet.add(“a”)只有一个参数）</h2><p>要看仔细底层源码，HashSet的底层肯定是HashMap，那么添加时的Key和Value是怎么处理的呢，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，确实是HashSet。再看add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，map的key是要插入的值，map的value统一是一个空对象。同时根据map的key不能重复就可以实现set元素不能重复的功能了。</p>
<p>那么如何得到一个值呢？如果插入到一个节点的值只有value，不久获取不到key了，那set的功能也失效了，看源码可以知道，Node有四个变量，其中就有 key 和 value，也就是说都节点把信息都保存了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-死锁的编码的排查"><a href="#2-死锁的编码的排查" class="headerlink" title="2. 死锁的编码的排查"></a>2. 死锁的编码的排查</h2><p>自己写一个Demo模拟死锁，首先我们要知道死锁是怎么发生，即两个或两个以上的线程同时争抢资源造成的互相等待的局面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得了锁"</span> + lockA + <span class="string">", 尝试获得锁"</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得了锁"</span> + lockB + <span class="string">", 尝试获得锁"</span> + lockA);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MySource mySource = <span class="keyword">new</span> MySource(<span class="string">"lockA"</span>, <span class="string">"lockB"</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(mySource::getLock1, <span class="string">"thread1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(mySource::getLock2, <span class="string">"thread2"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么怎么证明是死锁呢？这个程序还好说，因为是我们自己写的，我们知道是死锁，但是在现实中，程序卡住不走了，我们怎么知道是不是死锁造成的呢？有可能是死循环等等。我们用 jps 和 jstack 来进行排查。</p>
<p><code>jps</code> 命令展示正在执行的java<strong>进程</strong>机器id。<code>jstack</code> 命令是堆栈跟踪工具，主要用来查看java线程的<strong>调用堆栈和状态</strong>，可以用来分析线程问题，如死锁。</p>
<p>首先用jps命令找到此进程的编号，然后执行命令 <code>jstack 编号</code> 就可以看到是否有死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread2&quot;:</span><br><span class="line">        at Main$MySource.getLock2(Main.java:28)</span><br><span class="line">        - waiting to lock &lt;0x00000007812fc5c0&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000007812fc5f8&gt; (a java.lang.String)</span><br><span class="line">        at Main$$Lambda$2/1831932724.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">        at Main$MySource.getLock1(Main.java:19)</span><br><span class="line">        - waiting to lock &lt;0x00000007812fc5f8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000007812fc5c0&gt; (a java.lang.String)</span><br><span class="line">        at Main$$Lambda$1/1096979270.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>jstack</code> 能够帮我们找出死锁，然后我们在回到程序中进行改善即可。</p>
<ol>
<li>SpringCloud微服务的相关问题</li>
<li>jdk1.7和jdk1.8的hashmap有什么不同</li>
<li>JAVA各种集合以及区别</li>
<li>多线程的线程池是如何工作的，底层源码和原理</li>
<li>本地线程threadlocal的实现原理</li>
<li>Springboot 和 SpringMVC的区别</li>
<li>JVM的三种回收方式有什么不同，CMS和G1有什么区别（即回收机制和回收器）</li>
<li>数据库优化时候索引有哪几种索引，如何选择？</li>
<li>多人同时抢购一个库存的商品应该怎么处理（分布式事务）</li>
<li>如何处理高并发，也就是请求数量大于本地线程数量的时候不出错</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/12/19/单例类/">单例类</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://baoyixiang.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/知识总结/">知识总结（持续更新。。。）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/单例类/">单例类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/30/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">一路向前.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
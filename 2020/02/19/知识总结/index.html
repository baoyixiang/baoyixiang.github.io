<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习Java开发,SpringBoot进行Web开发"><title>知识总结（持续更新。。。） | 一路向前</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">知识总结（持续更新。。。）</h1><a id="logo" href="/.">一路向前</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">知识总结（持续更新。。。）</h1><div class="post-meta">Feb 19, 2020</div><div class="post-content"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-JVM-垃圾回收的时候如何确定垃圾，介绍GC-Roots"><a href="#1-JVM-垃圾回收的时候如何确定垃圾，介绍GC-Roots" class="headerlink" title="1. JVM 垃圾回收的时候如何确定垃圾，介绍GC Roots"></a>1. JVM 垃圾回收的时候如何确定垃圾，介绍GC Roots</h2><ol>
<li><strong>引用计数器法</strong>，每个对象分配一个引用计数器，每当有一个地方引用，就加一，计数器为0，就是可以回收的垃圾，最主要的缺点是<strong>对象之间循环引用的问题</strong>。</li>
<li>所以更多的采用 <strong>枚举根节点做可达性分析算法</strong>。引用不可达的对象则为垃圾，这里的可达就是指是否有指向GC Root的链路，如果有就就是可达。那么哪些对象可以做为 GC Root<strong>对象</strong>呢？<ol>
<li>虚拟机栈中（局部变量表）中<strong>引用的对象</strong>。</li>
<li>方法区中的类 <strong>静态属性</strong> 引用的对象。</li>
<li>方法区中 <strong>常量</strong> 引用的对象</li>
<li>本地方法区中（Native方法）中引用的对象</li>
</ol>
</li>
</ol>
<h2 id="2-JVM调优和参数配置"><a href="#2-JVM调优和参数配置" class="headerlink" title="2. JVM调优和参数配置"></a>2. JVM调优和参数配置</h2><p><strong>先说一下如何查看参数设置值</strong></p>
<p>首先用<code>jps -l</code>命令查看进程的id，然后用 <code>jinfo -flag 参数 id</code> 命令来查看这个参数的设置值。例如 <code>jinfo -flag MetaspaceSize 4300</code> 就能看到 4300 号进程现在 <code>MetaspaceSize</code> 参数的值。<code>jinfo -flags 4300</code> 可以看到<strong>所有参数</strong>的值。</p>
<p><strong>接下来再看看有哪些类型的参数。</strong></p>
<ol>
<li><p>标配参数，了解即可</p>
<p>-version,   -help 等基本不变的。</p>
</li>
<li><p>X参数，了解即可</p>
<p>-Xint：解释执行。-Xcomp：第一次就编译成本地代码，而不是边解释边执行。-Xminxed：混合模式，</p>
</li>
<li><p><strong>XX参数</strong></p>
<ol>
<li>Boolean类型：-XX:+(开启)/-(关闭)xxx， 例如是否打印GC收集细节为 <strong>-XX:+/-PrintGCDetails</strong>。是否使用串行垃圾回收器为 <strong>-XX:+/-UseSerialGC</strong>。</li>
<li>KV类型：-XX:key=value。例如 <strong>-XX:MetaspaceSize=1024m</strong> 可以设置元空间大小。                                  <strong>-XX:MaxTenuringThreshold=100</strong> 可以设置<strong>新生代</strong>经过多少代变为<strong>老年代</strong>。还有初始化堆的大小为        <strong>-XX:InitialHeapSize=100m</strong>。</li>
</ol>
</li>
</ol>
<p>说一个坑爹的题目，有两个经典的参数<strong>-Xms1024m 和-Xmx1024m</strong> 到底是X参数还是XX参数呢。其实这个是简写，<strong>-Xms1024m 等价于 -XX:InitialHeapSize=1024m</strong>，而 <strong>-Xmx1024m 等价于 -XX:MaxHeapSize=1024m</strong>。</p>
<p><strong>查看参数的命令</strong></p>
<ul>
<li><p><strong>-XX:+PrintFlagsInitial</strong>：可以查看所有的Jvm初始化参数，<code>java -XX:+PrintFlagsInitial</code></p>
</li>
<li><p><strong>-XX:+PrintFlagsFinal</strong>：查看变更之后的值，可以是手动修改的，也可能是JVM根据机器配置自动修改的。在展示的结果中，key=value表示初始值，key:=value表示修改之后的值。例如执行命令                                               <code>java -XX:+PrintFlagsFinal -XX:MetaspaceSize=1024m demo.java</code> 在结果中会有 <strong>MetaspaceSize:=某值</strong></p>
</li>
<li><p><strong>-XX:+PrintCommandLineFlags</strong>：此参数则只打印出被修改过的参数（<strong>包括JVM自动优化的</strong>）。</p>
</li>
</ul>
<p><strong>其他常用参数</strong></p>
<ul>
<li><p><strong>-Xms</strong>：堆内存的初始大小，默认为物理内存的1/64，等价于 -XX:InitialHeapSize=。</p>
</li>
<li><p><strong>-Xmx</strong>：堆内存的最大大小，默认为物理内存的1/4，等价于-XX:MaxHeapSize=。</p>
</li>
<li><p><strong>-Xss</strong>：单个<strong>线程栈</strong>的大小，默认为512K-1024K，等价于-XX:ThreadStackSize=。</p>
</li>
<li><p><strong>-Xmn</strong>：堆中新生代的大小，一般不调。</p>
</li>
<li><p><strong>-XX:MetaspaceSize=</strong>：1.8的元空间与之前的永久代类似，都是方法区的实现，区别在于元空间直接使用物理内存，而永久代则在虚拟机中。理论上来说元空间的大小受本地内存大小的限制，但是初始大小一般为20M左右，为了避免内存溢出，可以调大。</p>
</li>
<li><p><strong>-XX:+PrintGCDetails</strong>：打印垃圾回收的具体细节，<strong>要学会看打印结果</strong>。</p>
<p><code>[GC (Allocation Failure) [PSYoungGen: 1808K-&gt;488K(2560K)] 1808K-&gt;672K(9728K), 0.0375740 secs] [Times: user=0.00 sys=0.00, real=0.04 secs]</code></p>
<p><code>[Full GC (Allocation Failure) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 200K-&gt;640K(7168K)] 704K-&gt;640K(9728K), [Metaspace: 3438K-&gt;3438K(1056768K)], 0.0038271 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p>
<p>格式为 ：<strong>[哪个区：GC前的大小 -&gt; GC后的大小（这个区总的大小）] … 堆GC前大小-&gt;堆GC后大小(堆总大小)</strong></p>
</li>
<li><p><strong>-XX:SurvivorRatio=</strong>：在堆的新生代中分为 Eden区和 from、to区，此参数就是设置 Eden 区的比例，form和to区的大小相同。例如值为4，那么Eden : from : to = 4 : 1: 1。</p>
</li>
<li><p><strong>-XX:NewRatio=</strong>：堆中新生代和老年代的大小比例，默认为2，则新生代 : 老年代 = 1:2。若改为4，则比例为1:4。</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold=</strong>：设置新生代中对象的最大年龄，即经过多少次回收依然存活的对象，则进入老年代。只能在 0 到 15 之间，默认为15。</p>
</li>
</ul>
<h2 id="3-四种类型的引用"><a href="#3-四种类型的引用" class="headerlink" title="3. 四种类型的引用"></a>3. 四种类型的引用</h2><ol>
<li><p><strong>强引用</strong></p>
<p>在代码中普遍存在，类似于 “Object ob = new Object()”，只要<strong>有一个</strong>强引用存在，垃圾回收器永远不会回收被引用的对象，即使出现了 OOM。</p>
</li>
<li><p><strong>软引用</strong></p>
<p>简单一句话就是，<strong>内存足够就不回收，内存不足够就回收</strong>，<strong>以避免发生 OOM（目的）</strong>，即在系统将要发生内存溢出之前，把这些对象进行回收，回收之后内存还是不够，再抛出 OOM。<code>SoftReference</code> 实现了软引用。</p>
</li>
<li><p><strong>弱引用</strong></p>
<p>不管内存够不够，都会被回收，即<strong>只被</strong>弱引用引用的对象只能存活到下一次垃圾回收之前。<code>WeakReference</code> 实现了弱引用。</p>
<p>软引用和弱引用的使用场景：一般在用到<strong>缓存</strong>的时候，会考虑到软弱引用，比如读取一张图片，每次进行IO读的话就很耗时，就可以把它缓存到内存中，在内存不够的时候，就可以把它回收掉，避免发生OOM，这个一个很合理的使用场景。</p>
<p>其应用之一就是 <code>WeakHashMap</code>，它的特点是，如果一个键引用的对象没有被其他的引用所引用，下次垃圾回收，就回回收掉这个键值对。意思就是说，这个<strong>键是一个弱引用。</strong>而HashMap的键是一个强引用，即使没有被其他强引用所引用，它也被这个引用所引用着。<code>WeakHashMap</code> 的特性使得它很适合做<strong>缓存的实现</strong>，可以让JVM自动的回收垃圾，避免OOM。</p>
</li>
<li><p><strong>虚引用</strong></p>
<p>虚引用不会决定对象的生命周期，<strong>就像这个对象没有被引用一样</strong>，虚引用必须和引用队列（ReferenceQueue）一起使用，其实现用 <code>PhantomReference</code>。</p>
<p>其作用是在这个对象被回收时收到一个系统通知。<strong>对象被回收之后，其引用会被放到引用队列中</strong>。通过这个我们就能跟踪到一些回收信息，并做一些<strong>后置通知</strong>。</p>
</li>
</ol>
<h2 id="4-内存异常"><a href="#4-内存异常" class="headerlink" title="4. 内存异常"></a>4. 内存异常</h2><ol>
<li><p><strong>StackOverflowError</strong></p>
<p>栈溢出，最典型的就是递归调用太深了。</p>
</li>
<li><p><strong>OOM:java heap space</strong></p>
<p>Java堆溢出，对象数量达到最大堆的容量限制之后，就会产生堆溢出。解决此问题一般先看能不能调大虚拟机的 -Xms 和 -Xmx 参数，如果还不能满足，就要检查是否有的对象生命周期过长等，尝试减少堆的消耗。</p>
</li>
<li><p><strong>OOM:GC overhead limit exceeded</strong></p>
<p>GC回收垃圾的时间过长，消耗了大量资源，<strong>回收效果却不好</strong>。回收效果不好会导致GC再次回收，从而造成恶性循环。所以会报这个错误，直接不收了。</p>
</li>
<li><p><strong>OOM:Direct buffer memory</strong></p>
<p>本地直接内存溢出了，场景：有时候为了效率，我们会将对象分配在本地直接内存中，这样避免了java堆与本地内存间的复制，尤其是使用NIO的时候。<strong>但是这部分的对象不受GC管了</strong>，如果我们不加控制的分配，则可能会造成本地直接内存的溢出。可以用内存映像分析工具对堆内存进转储成文件，<strong>如果我们看到堆内存中的对象很少，而又使用到了NIO，就要考虑是不是这个问题了。</strong></p>
</li>
<li><p><strong>OOM:unable to create new native thread</strong></p>
<p>在多线程环境下会产生这个错误，原因就是剩下的内存已经不够你再创建新的线程了。解决方法有点违背常规思维，要通过<strong>减少栈容量（参数为-Xss）</strong>来换取更多的线程。或者改进程序，不要创建那么多的线程。还有个原因就是Linux系统会限制线程上限，我们也可以修改这个上限，当然是内存容量允许的情况下。</p>
</li>
<li><p><strong>OOM:Metaspace</strong></p>
<p>方法区中保存的有<strong>虚拟机加载的类的信息、常量池、静态变量和即使编译后的代码等</strong>，一般什么情况下会产生大量的类呢？<strong>在用反射或者字节码技术对类进行动态增强的时候，会产生新的类</strong>，现在的一些主流框架如Spring等就会对类进行动态增强，当我们在这样的场景下，就可能会碰到这个异常。</p>
</li>
</ol>
<p>要说一下，StackOverflowError 和 OOM 都是 Error 而不是 Exception，两者的区别在于，Exception是可以被捕获和处理的，一般是程序员写的代码造成的问题，而Error是不能程序员捕获和处理的，原因一般都比较底层。</p>
<h2 id="5-垃圾回收算法"><a href="#5-垃圾回收算法" class="headerlink" title="5. 垃圾回收算法"></a>5. 垃圾回收算法</h2><ul>
<li><p><strong>标记-清除算法</strong>：回收时，先标记垃圾，再统一回收标记的垃圾。这种算法首先效率低，第二会产生碎片，碎片会导致下次要分配大对象时，本可以不触发回收却产生了回收。</p>
</li>
<li><p><strong>复制算法</strong>：将内存分为两块，每次回收时，将还存活的对象复制到另一块，然后清除掉这一块所有的对象。缺点是降低了内存利用率。为解决这一缺点，会将堆分为 Eden 和 两块相同大小的 Survivor区，一般比例为 8:1:1，<strong>每次用 Eden 区和一块Survivor区，回收时则将这两个区存活的对象复制到另一块Survivor区</strong>。复制的这种特性适合<strong>新生代</strong>，因为新生代存活的周期短，需要复制的就少，复制消耗的资源就少。</p>
</li>
<li><p><strong>标记-整理算法</strong>：</p>
<p>复制算法对于老年代的对象就很不适用了。标记整理算法就是将存活的对象移动到内存头部，然后把尾部的对象都回收掉。</p>
</li>
<li><p><strong>分代收集算法</strong>：</p>
<p>就是按照新生代和老年代，用不同的算法。新生代用复制算法，老年代用标记清除或者标记整理算法。</p>
</li>
</ul>
<h2 id="6-垃圾回收器"><a href="#6-垃圾回收器" class="headerlink" title="6. 垃圾回收器"></a>6. 垃圾回收器</h2><h3 id="怎么看JVM的垃圾回收器"><a href="#怎么看JVM的垃圾回收器" class="headerlink" title="怎么看JVM的垃圾回收器"></a>怎么看JVM的垃圾回收器</h3><p>用 <code>-XX:+PrintFlagsInitial</code> 等参数可以看到，并且可以用<code>-XX:+UseSerialGC</code> 、 <code>-XX:+UseParallelGC</code>、<code>-XX:+UseConcMarkSweepGC</code> 、<code>-XX:+UseParNewGC</code>、<code>-XX:+UseParallelOldGC</code>、<code>-XX:+UseG1GC</code> 来设置</p>
<h3 id="垃圾回收器概括"><a href="#垃圾回收器概括" class="headerlink" title="垃圾回收器概括"></a>垃圾回收器概括</h3><p>新生代：Serial,        ParNew,  Parallel Scavenge</p>
<p>老年代：Serial Old,    CMS，     Parallel Old</p>
<p>不区分新老：java8才用的 G1</p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>一句话就是：由<strong>一个线程</strong>进行垃圾回收，并且会<strong>暂停其他所有的工作线程</strong>（Stop the world）。优点是简单高效。</p>
<p>设置参数为 <code>-XX:+UseSerialGC</code>，此时老年代会默认用 Serial Old 回收器。新生代算法用<strong>复制算法</strong>，老年代用<strong>标记-整理算法</strong></p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>一句话就是：使用<strong>多线程</strong>进行垃圾回收，也会暂停其他所有的工作线程，就是Serial的多线程版本，有点当然就是回收快。<strong>它最常见的应用是为了配合老年代的 CMS 收集器。</strong>因为另一个并行收集器 Parallel Scavenge 不能同 CMS 一起使用。</p>
<p>设置参数为 <code>-XX:+UseParNewGC</code>，算法用的是复制算法。并且当设置 <code>-XX:+UseConcMarkSweep</code>参数后，也会默认使用这个收集器。还可以使用<code>-XX:ParallelGCThreads</code> 参数来设置回收垃圾线程的上限数。</p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>也是在<strong>新生代</strong>的<strong>多线程</strong>收集器，算法用的复制算法。主要是为了 Parallel Scavenge + Parallel Old 组合使得新老代都可以并行回收。</p>
<p>它和其他回收器关注用户程序的停顿，它的不同在于达到一个<strong>可控制的吞吐量</strong>：吞吐量 = 运行用户程序的时间 / （运行用户程序时间  +  垃圾回收的时间）。<strong>停顿时间短适合用户交互多的场景，吞吐量不一定高，而吞吐量高的目的在于高效利用CPU资源，适合后台运算而不需要很多用户交互的场景</strong></p>
<p>可以用<code>-XX:MaxGCPauseMillis</code> 控制最大垃圾回收时间，用<code>-XX:GCTimeRatio</code> 设置吞吐量大小。前者我们不能设置太小了，因为停顿时间牺牲了吞吐量。</p>
<p>Parallel Scavenge 回收器还有一个特点是它有<strong>自适应调节策略</strong>，可以打开参数<code>-XX:+UseAdaptiveSizePolicy</code>,然后JVM会收集性能监控信息，<strong>动态调整各项参数以提供最合适的停顿时间和吞吐量大小</strong></p>
<p>参数<code>-XX:+UseParallelGC</code> 和 <code>-XX:+UseParallelOldGC</code> <strong>可以相互激活</strong>。</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Scavenge 收集器的老年代版本，用标记整理算法。</p>
<p>咋Java1.6之前，没有这个收集器，所以<strong>Parallel Scavenge 只能和Serial Old组合（不能和CMS）组合</strong>，地位比较尴尬。当有了这个收集器后，“吞吐量优先”收集器就有了名副其实的组合了。这个组合在注重<strong>吞吐量和CPU敏感</strong>的场景下，可以优先考虑。</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial 收集器的老年代版本，使用标记整理算法，其用途为在Java1.6之前与 Parallel Scavenge 配合使用，还有一个用途就是作为 <strong>CMS 的后备方案</strong>，在并发收集器Concurrent Mode Failure时使用。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>全称为 Comcurrent Mark Sweep, 即<strong>并发标记清除</strong>，好处是可以<strong>获得很短的用户程序停顿时间</strong>，它的算法<strong>基于标记-清除算法</strong>。也是到目前为止唯一<strong>体现了并发</strong>的收集器，但并不代表说它完全不会Stop the world， 下面会讲到。</p>
<p>设置 <code>-XX:+UseConcMarkSweep</code>参数后会开启 CMS收集器，并且新生代用 <strong>ParNew 收集器</strong>。当CMS失效后，用Serial Old作为后备。</p>
<p>CMS收集器由四个步骤：</p>
<ul>
<li><p>初始标记（CMS initial mark，会暂停用户线程）</p>
<p>仅仅标记一下 GC Roots <strong>直接关联</strong>到的对象（即根节点的第一个子节点），速度很快。</p>
</li>
<li><p>并发标记（CMS concurrent mark，<strong>不会</strong>暂停用户线程）</p>
<p>和用户线程一起运行，进行 GC Roots trancing ，遍历所有的对象，能遍历到的就是可存活的了。</p>
</li>
<li><p>重新标记（CMS remark，会暂停用户线程）</p>
<p>修正因程序继续运行状态变了的对象。</p>
</li>
<li><p>并发清除（CMS concurrent sweep，<strong>不会</strong>暂停用户线程） </p>
<p>经过前三步，就实现了标记-清除算法的标记步骤，标记除了所有的存活对象，在这一步就回收其他对象即可。</p>
</li>
</ul>
<p>其中，最耗时的步骤2和步骤4是和用户线程一起并发执行的。<strong>所以停顿非常低</strong></p>
<p>其缺点有三：</p>
<ol>
<li><strong>CPU压力大</strong>，抢占了工作线程的CPU资源，工作线程的速度就会有一定程度的减慢。</li>
<li>由于是采用的标记-清除算法，所以会<strong>导致碎片</strong>，可以使用<code>-XX:+UseCMSCompactAtFullCollection</code> 参数，让JVM顶不住，要进行Full GC回收老年代时进行<strong>碎片整理。</strong> </li>
<li>可能会导致 <strong>Concurrent Mode Failure</strong>, 因为是并发回收，所以在回收的时候还可能会产生垃圾，在CMS回收期间，其内存不够工作线程使用，就会产生这个问题，这个时候会用 Sertial Old 收集器作为后备进行一次 Full GC，这样停顿时间反而变得更长了，所以这个要避免。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器的特点：</p>
<ul>
<li>并发与并行：G1收集器与CMS收集器类似，都有并发和并行。</li>
<li>分代收集：虽然使用G1收集器时，不再有新生代和老年代，而是分成一个个 <strong>Region</strong>, 但是每一个 Region 都可能是 Eden、S区、或者老年代区，还有大对象区，还是做到了分代收集。这个时候，新生代和老年代不再是物理连续，而是逻辑连续，回收也是<strong>局部回收</strong>，在底层用了 <strong>Remebered Set</strong> 来记录 Region 之间的引用关系，避免<strong>全局扫描。</strong></li>
<li><strong>空间整合</strong>：<strong>即没有碎片</strong>，G1收集算法从整体上看是基于 标记整理（<strong>局部复制时，都是追加复制到一个新的Region，这样就相当于整理了</strong>），从局部上看（<strong>两个 Region之间，比如Eden区和S0区将存活的对象复制到另一个S1区的Region</strong>）是复制算法，这两个算法都意味着没有碎片。</li>
<li><strong>可预测的停顿</strong>：G1收集器可以让用户明确指定停顿时间不超过一个值。之所以能做到这样，是因为G1可以追踪每个Region里面垃圾回收的耗时比对，在后台维护一个<strong>优先队列</strong>，<strong>每次根据允许的停顿时间，回收价值最大的垃圾。</strong>(这也是 Garbage-First 的由来)</li>
</ul>
<p>回收步骤也分为四步</p>
<ul>
<li>初始标记：仅仅标记与 GC Roots直接相关的对象</li>
<li>并发标记：进行可达性分析。</li>
<li>最终标记：修正在程序运行中对象标记的变化</li>
<li>筛选回收：前三步与CMS基本一样。最后一步区别在于<strong>筛选</strong>，即上述特点的第四点，根据用户所期望的停顿时间来筛选要回收的Region。</li>
</ul>
<p>G1相关的JVM参数：</p>
<ul>
<li><code>-XX:+UseG1GC</code>: 开启G1收集器</li>
<li><code>-XX:G1HeapRegionSize=</code>: 设置每个Region的大小，要为2的次幂，在1M-32M之间。</li>
<li><code>-XX:MaxGCPauseMills=</code>: 这个就是用户可以设置的最大预期时间，不能太小，太小了吞吐量可能变大。</li>
<li><code>-XX:ConcGCThreads=</code>: 并发GC的线程数</li>
</ul>
<h3 id="如何选择合适的垃圾收集器"><a href="#如何选择合适的垃圾收集器" class="headerlink" title="如何选择合适的垃圾收集器"></a>如何选择合适的垃圾收集器</h3><ul>
<li>单CPU或小内存：<code>-XX:+UseSertialGC</code></li>
<li>多CPU，追求运算的吞吐量，适合多运算的程序：<code>-XX:+UseParallelGC</code> ， <code>-XX:+UseParallelOldGC</code>。</li>
<li>多CPU，追求低停顿，适合多交互的程序：<code>-XX:+UseConcMarkSweepGC</code> ，<code>-XX:+ParNewGC</code></li>
</ul>
<h2 id="7-内存分配和回收策略"><a href="#7-内存分配和回收策略" class="headerlink" title="7. 内存分配和回收策略"></a>7. 内存分配和回收策略</h2><p>本节会讲几条最普遍的内存分配机制</p>
<ul>
<li><strong>对象优先在 Eden 区分配</strong>：大多数情况下，对象在新生代 Eden 区中分配。当Eden区没有足够的空间时，会进行一次 Minor GC（即新生代的复制算法的GC）。</li>
<li><strong>大对象直接进入老年代</strong>：出现大对象是个不好的事，经常出现大对象容易导致提前GC来存放它们，生命周期短的大对象就更不好了，因为本来事Minor GC 的事，现在却要出发耗时的 Full GC。</li>
<li><strong>长期存活的对象进入老年代</strong>：一个分配在Eden区的对象，每在 Survivor 区生存一次Minor GC，年龄就加1，当年龄到达一定值，就会进入老年代，这个值可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</li>
<li><strong>空间分配担保</strong>：在进行Minor GC时，<strong>垃圾很少时，复制算法中 Survivor 区可能不够用</strong>，这个时候就要用老年代来做分配担保，把 Survivor 中无法容纳的对象存入老年代。那么老年代空间也不够的话，就有担保失败的危险，所以在进行Minor GC之前，<strong>会将老年代剩余的空间与新生代所有对象的大小作比较</strong>（因为GC之前，不可能知道到底有多少存活），如果新生代剩余的空间小，则进行一次 Full GC来腾空间，否则直接进行Minor GC。</li>
</ul>
<h1 id="多线程和高并发"><a href="#多线程和高并发" class="headerlink" title="多线程和高并发"></a>多线程和高并发</h1><h2 id="1-谈谈-volatile-关键字"><a href="#1-谈谈-volatile-关键字" class="headerlink" title="1. 谈谈 volatile 关键字"></a>1. 谈谈 volatile 关键字</h2><p>首先说一下JMM，JAVA内存模型，一般来说，主内存是只内存，工作内存是指缓存Cache，一个处理器处理一个线程，这个处理器的Cache就是这个线程的工作内存，根据JMM规范，应该要保证<strong>可见性、原子性、有序性</strong>。</p>
<p>而volatile关键字可以保证可见性和有序性，并不能保证原子性</p>
<ul>
<li><p><strong>保持可见性</strong></p>
<p>主内存是线程共享的，工作内存是线程独立的，一个线程要操作主内存的数据，先从主内存的数据拷贝回自己的工作内存再进行操作，再写回到主内存。这样别的线程并不知道这个变量已经改了。保持可见性的意思就是当一个线程已经修改了主内存的变量的值，其他的线程能够立马收到最新消息。</p>
<p>那么是如何保持可见性的呢？首先修改变量线程的CPU在修改完变量后，不仅仅只写入对应的Cache，还会同时回写到主内存中，这样主内存中的值一直都是最新的，那如何保证其他线程的变量也是最新的呢？根据缓存一致性原则，当一个CPU写了变量，会通知其他CPU对应的缓存行失效，当其他CPU使用此变量的时候，会发现缓存行已经失效，就会从主内存中刷新变量</p>
<p>在汇编的层次，是在add命令之前加了个lock命令，这会使得lock后面的写操作，立即回写到主内存，同时使得<strong>总线上</strong>其他CPU的缓存行失效。这个是“嗅探”原理，即所有的CPU共享一条总线，数据交换都是通过这条总线，所以一个CPU修改数据，其他缓存能够“嗅探”到。另外，一个缓存行有状态标记，嗅探到了，使标记为无效即可。</p>
<p>参考文章（非常深入）：<a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="noopener">深入理解Volatile关键字及其实现原理</a></p>
</li>
</ul>
<ul>
<li><p><strong>禁止指令重排</strong></p>
<p>在单线程下，指令重排是不会影响数据的最终一致性的，但是在多线程下，指令重排就会影响，下面给个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只有一个线程，那么 a = 2  和 flag = true 这两条语句的顺序颠倒是不会影响 method2中的打印结果的。因为一个线程顺序执行method1和method2。当在多线程环境下，线程A执行method1，线程B执行method2，如果 a = 2 和 flag = true 的顺序变了，当 线程A的flag = true 执行完之后，线程B进来了，这个时候线程B的打印结果是 0 而不是 2。</p>
<p>再看一个案例，是双重检验单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 加锁之后，即使某个线程获取时 instance 不为空，也会阻塞在这，所以要再加一个判断</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 如果这里不加锁的话，两个线程同时判断时，会都为空</span></span><br><span class="line">                <span class="comment">// 两个线程获得的实例并不是单例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，instance 要用volatile修饰，因为 <code>instance = new Singleton()</code> 分三步：</p>
<ol>
<li>在堆内存中给实例分配空间</li>
<li>初始化这个实例</li>
<li>将实例对象的地址赋值给instance变量</li>
</ol>
<p>如果不禁止指令重排，第三步有可能会在第二步之前执行，这个时候，instance并不为空，会直接返回一个未初始化完成的实例对象。</p>
</li>
</ul>
<ul>
<li><p><strong>不能保证原子性</strong></p>
<p>最常见的一个例子就是 i++ 自增操作，自增操作不是原子操作，分为三步：</p>
<ol>
<li>从缓存中获取变量 i</li>
<li>自增 i</li>
<li>回写到缓存中</li>
</ol>
<p>当两个线程A，B同时进行i++操作时，先同时对缓存中读取 i，然后进行 +1 操作，即使变量i进行了volatile修饰，A线程通知了B线程缓存行失效，<strong>但是B此时已经不需要读这个缓存行了，刷新的前提是读缓存行时发现失效了</strong>，这个时候A和B都会回写到主内存中，发生了覆盖。（要知道，原子操作还是很少的，所以volatile的作用还是很有限的）</p>
<p>如何解决呢？ 1. 加synchronize锁，2. 用AtomicInteger（CAS操作保证原子性）</p>
</li>
</ul>
<h2 id="2-CAS"><a href="#2-CAS" class="headerlink" title="2. CAS"></a>2. CAS</h2><p>CAS的意义就是比较并交换，即只有当我们的预期值没有被修改时，才去修改变量，先看看 AtomicInteger 是如果利用CAS来保证 i++ 会造成的写覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger <span class="keyword">int</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span>.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>); </span><br><span class="line"><span class="comment">// 当第一个线程想要将新值 2019 写回主内存的时候，期望主内存的值是5，才将值更新为2019</span></span><br><span class="line"><span class="comment">// 第一个线程成功之后，第二个线程再执行这条语句就会失败，这样就避免了 写覆盖</span></span><br><span class="line"><span class="comment">// 当然这里的5肯定不是这样直接给的，在接下来的源码中会分析到。</span></span><br></pre></td></tr></table></figure>

<p>先看看AtomicInteger的自增方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unsafe 类是为了提高JAVA的效率，因为java不能操作底层，unsafe类使得java可以向c语言一样使用指针来操作内存，因为unsafe类中的方法基本都是native修饰的，在底层则是用c语言实现的。我们可以看到参数有 <code>this</code> 和<code>valueOffset</code>, 通过这两个可以得到这个变量在内存中的真实地址。同时，unsafe类中的compareAndSwap方法是原语操作，保证了原子性。</p>
<p>我们接着往下看，这段代码是核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var1是AtomicInteger实例的首地址，var2是value的偏移地址</span></span><br><span class="line">        <span class="comment">// 通过这条语句，可以得到主内存中的 value 的值</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这这个间隙，其他的线程可能会修改掉主内存的数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// while中的语句就是unsafe类中的语句，是原子语句，执行时不会再发生写覆盖</span></span><br><span class="line">        <span class="comment">// 其意思就是，根据var1和var2获取到主内存中的值，如果这个值还是var5，</span></span><br><span class="line">        <span class="comment">// 说明没有被其他的线程修改，我这个线程就可以直接修改</span></span><br><span class="line">        <span class="comment">// 如果不为var5了，说明被其他线程修改了，就不能修改，回到循环体中</span></span><br><span class="line">        <span class="comment">// 当回到循环体中后，由于value是被volatile修饰过的（必须的），</span></span><br><span class="line">        <span class="comment">// 所以获得到的var5是最新的别人修改过的。</span></span><br><span class="line">        <span class="comment">// 然后再进行一次这样的判断。</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我理解的本质就是，不用CAS时，线程修改数据，有从主内存取得数据、修改数据、回写数据这三步，在回写数据这一步，可能主内存已经被别的线程回写过了，就会发生回写覆盖。为了解决这个，CAS在回写的时候会<strong>将主内存与自己工作内存之前取得的值比较一下</strong>，就可以判断出是否已经被别人修改过了，如果没有，我就可以修改，不过别人修改过了，我再去一次，在最新的值上面再修改。</p>
<p>那么为什么用CAS而不用Synchronized锁呢，要知道，加锁之后，最耗时的就是线程的上下文交换，也就是线程被挂起和被唤醒的过程，在这个过程中，操作系统会在核态和用户态之间切换，要保存运行环境和回复运行环境，这些都是很费事的，在JAVA1.6之后优化的自旋锁就是为了避免上下文交换。通过上面的分析可以看到，do，while循环也避免了线程的上下文交换，性能会高很多。</p>
<p>最后再讲一下CAS的缺点</p>
<ol>
<li>首先虽然CAS没有挂起线程，增加了并发性，但是当很多个线程进行自旋，就会白白耗费CPU资源，这种并发，就只是让很多线程在那循环等待。</li>
<li>只能保证一个共享变量的原子操作。CAS要有一个compare，一个变量就好比对，如果是段代码，一个类呢？synchronized就能锁这样的，当时还有AtomicReference等类有相应的操作。</li>
<li>ABA问题，会在下一节详细讲一下ABA问题</li>
</ol>
<h2 id="3-CAS中的ABA的问题"><a href="#3-CAS中的ABA的问题" class="headerlink" title="3. CAS中的ABA的问题"></a>3. CAS中的ABA的问题</h2><p>先有两个线程，其中一个线程运行的比较快，将主内存中的变量从 A 改成了 B， 再从 B 改成了 A，这个时候，另外一个线程调用 compareAndSwap方法时，会发现期望值与实际值是相同的，它并不知道中间已经被修改过了，它就会修改掉这个值。</p>
<p>当我们的实际问题不能容忍这个被修改的过程，这个问题就很严重了，比如会员卡的问题，用户消费20元，紧接着再充值20元，如果积分统计线程是根据余额的减少来统计积分的，那就严重了，积分统计线程并不知道用户已经消费过了，积分没统计上，这是一个大漏洞。</p>
<p>那怎么解决呢？在加个变量（时间戳）来标识这个变量是否被修改过了。这样下来，在执行 compareAndSet() 方法的时候，不仅仅比较变量是否相等，还要比较时间戳是否相等。AtomicStampReference类则实现了这个功能，我们看一下构造函数和对应的 compareAndSet() 方法的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference(V initialRef, <span class="keyword">int</span> initialStamp)</span><br><span class="line">compareAndSet(V expectedReference, V newReference, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span><br></pre></td></tr></table></figure>

<p>在实际使用的时候，<code>newStamp</code> 的设置是手动的，我们一定要每次设置都是递增以保证不会跟之前的重复，否则时间戳也会出现ABA问题。</p>
<h2 id="4-线程安全的集合类"><a href="#4-线程安全的集合类" class="headerlink" title="4. 线程安全的集合类"></a>4. 线程安全的集合类</h2><p>这一节包括下一节的 JUC 中线程安全的容器在这里有总结：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">并发容器总结</a></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>先看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时会报 <code>java.util.ConcurrentModificationException</code> 错误。先讲一个为什么会出现这个问题。这是java集合类遍历时的fast-fail机制。</p>
<h4 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h4><p>fast-fail机制总结一下就是集合的iterator在遍历的时候会判断这个集合是否被其他线程修改过，如果被修改过，就抛出这个错误，提示用户现在出现了并发错误。</p>
<p>打印arrayList的时候会调用其 toString() 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这就是集合的iterator遍历，我们再看看 next() 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在第一句，其作用就是，在一个线程遍历集合的过程中，每次获取下一个值之前都要先看看这个集合是不是被别的线程修改过，如果修改过，就抛出 <code>ConcurrentModificationException</code> 错误。我们再看看这个方法的源码就清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 modCount 和 expectedModCount 又是什么呢，这个跟 CAS 的思想有点像，即比较的思想。当一个线程获取的iterator时，<strong>会new一个新的iterator出来，expectedModCount是iterator的私有遍历，所以是线程私有的，在初始时，expectedModCount = modCount，</strong>在进行写操作时，比如add操作，就会 modCount++, 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法是 add方法调用的一个方法，可以看到进行了 modCount++</span></span><br><span class="line">    <span class="comment">// modCount 是共享变量。</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当另外一个线程添加了一个元素，遍历的线程调用next()的时候，会发现这个线程私有的 expectedModCount 与 线程共享的 modCount 不相等，就会抛出错误。</p>
<p>还有一种情况，即使在单线程下也会报这个错误，就是在遍历的过程中修改了这个集合，因为修改的时候只改变了modCount，没有改变 expectedModCount，造成了两者不一致。那么如何避免呢？即禁止在用iterator遍历的时候调用add、delete等写操作修改集合，而应该调用iterator<strong>的相应方法</strong>，为什么呢？我们看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);  <span class="comment">// 这个方法会修改modCount</span></span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;    <span class="comment">// 在这里同时也会修改 expectedModCount变量。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我再提个问，那么多线程的时候我们也用iterator对应的add方法可以吗？ 不行哦，别忘了，iterator是线程私有的，也就是说语句 <code>expectedModCount = modCount</code>  修改的 expectedModCount 只是修改了自己线程的 expectedModCount变量。所以唯一的解决方法就是写写加锁。</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>再说在并发情况下如何避免这个问题：</p>
<ol>
<li>用Vector，但是我们知道，Vector是暴力加锁，会降低性能，而且Vector也被废弃了</li>
<li>用Collections.synchorinzedList()方法包裹一些，这样也是暴力加锁</li>
<li>用 JUC 包中的 <code>CopyOnWriteArrayList</code> , 它是线程安全的list，只有在写写的时候会加锁，性能好很多。</li>
</ol>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>接下来讲讲 CopyOnWriteArrayList 的原理。看懂 add() 方法的源码就大概知道了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();   <span class="comment">// 获取原本的 array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">// 将 array 复制一份</span></span><br><span class="line">        newElements[len] = e; <span class="comment">// 修改复制后的array</span></span><br><span class="line">        setArray(newElements); <span class="comment">// 将修改后的array赋值给原本的array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CopyOnWriteArrayList的写操作并不是修改原本的array，而是复制一份进行修改。同时也加了锁，在多线程的情况下不会复制出多个副本。其读操作是没有加任何锁的，直接返回原本的 array。</p>
<p>为什么要复制呢？这是我写这部分时的一个问题，答案是为了读写分离，也就是为了在写的时候读操作不阻塞也能不出问题，先来分析一下，为什么如果写原数组时，不阻塞读操作会出错？因为读和写操作都不是原子操作，他们可能会交替执行。比如我们把上述代码改成如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();   <span class="comment">// 获取原本的 array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        len = len + <span class="number">1</span></span><br><span class="line">        elements[len] = e; <span class="comment">// 修改复制后的array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程执行到 <code>len = len + 1</code> 的时候，另外一个线程来进行读操作了，比如执行 <code>getLast()</code> 方法，即执行<code>get(len - 1)</code>, 但是现在这个位置是没有赋值上的，就出现了问题。但是如果修改时是复制一份来修改，另外一个线程读的时候就没有任何影响。这也就是为什么在没有这个容器之前，只能做到读读不加锁，读写，写读和写写都要加锁。有了这个容器，就可以只在写写的时候加锁了。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 同样也是线程不安全的，那如何避免呢？当然有一种是 <code>Collections.synchornizedSet()</code> 来加锁，这不是一个好的方法，好的解决方法是 CopyOnWriteArraySet。其原理非常简单，其源码也很少，因为它是基于CopyOnWriteArrayList 的，它内部有个 CopyOnWriteArrayList 变量，对其的操作都是操作的这个变量。比如add方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>当然也是不安全的，一种方法是用<code>Conllections.synchronizes()</code>方法加锁，更好的解决办法就是用JUC包中的 ConcurrentHashMap。</p>
<p><strong>ConcurrentHashMap：</strong></p>
<p>这里先简单的介绍一下，这一部分后续可能会研究一下源代码</p>
<ul>
<li><strong>底层数据结构</strong>：在JDK1.7的时候，ConcurrentHashMap用的是 <strong>分组的数组 + 链表</strong> 的方式，JDK1.8用的是跟HashMap一样的结构，即 <strong>数组 + 链表 / 红黑树</strong>。</li>
<li><strong>实现线程安全的方式</strong>：在JDK1.7的时候，使用的分段锁，它会把数组分成多个段(Segment)，每次加锁只在其中一个段上加锁，其余段上的线程不会阻塞，提高了并发量。在JDK1.8之后则直接使用了Synchronized + CAS的方法来实现线程安全。<strong>在用hash定位到数组的头节点时，如果没有发生冲突就用CAS来实现写操作的线程安全，如果发生了冲突，则锁住这个头节点。</strong></li>
</ul>
<h2 id="5-线程安全的队列"><a href="#5-线程安全的队列" class="headerlink" title="5. 线程安全的队列"></a>5. 线程安全的队列</h2><p>队列分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，阻塞队列是通过<strong>加锁</strong>实现的，非阻塞队列是通过<strong>CAS操作</strong>实现的。非阻塞队列只有一个，就是<code>ConcurrentLinkedQueue</code>，它是一个<strong>无界</strong>的安全队列，入队和出队都是用的 CAS 操作来保证线程安全性。那么为什么要用阻塞队列呢？阻塞听起来就不是个好词，因为阻塞队列可以做到，<strong>线程在向一个队满的队列插入数据时会阻塞挂起，在从一个对空的队列取数据时也会阻塞挂起，等到合适的时间再唤醒，继续执行</strong>，这就是阻塞的意思，同时，在进行写操作时，加了 <strong>ReentrantLock</strong> 来保证线程安全。而<strong>线程在从一个空的非阻塞队列中取数据时会直接取出null，执行完成</strong>，这在有时候是不符合实际业务的，比如生产者消费者模式，还有消息队列（恰恰，消息队列底层数据结构就是阻塞队列）。</p>
<p>关于阻塞队列，这篇文章非常详细：<strong><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">解读 java 并发队列 BlockingQueue</a></strong>，阻塞队列都是实现了 <code>BlockingQueue</code>接口，有如下7个：</p>
<ul>
<li><strong><code>ArrayBlockingQueue</code> ：由数组组成的有界阻塞队列</strong></li>
<li><strong><code>LinkedBlockingQueue</code>：由链表组成的有界（但默认大小为Integer.MAX_VALUE）阻塞队列</strong></li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li>
<li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列</li>
<li><strong><code>SynchronousQueue</code>：不存储元素的阻塞队列，即单个元素的队列</strong></li>
<li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列</li>
<li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">限时阻塞</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center"><strong>put(e)</strong></td>
<td align="center">offer(e, time, util)</td>
</tr>
<tr>
<td>移出</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center"><strong>take()</strong></td>
<td align="center">poll(time, util)</td>
</tr>
<tr>
<td>检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td>备注</td>
<td align="center">即在队满或者队空的时候，调用这三个方法会抛出异常</td>
<td align="center">即在队满的时候调用offer(e)直接返回false，元素不入队，在对空的时候调用 poll()和peek() 则返回null。</td>
<td align="center">在队满的时候调用put(e)和在队空的时候调用 take() 都会阻塞线程。<strong>常用的，因为这一对涉及到阻塞</strong></td>
<td align="center">可以设置<strong>阻塞的时间</strong>，当有这个需求的时候可以用这个</td>
</tr>
</tbody></table>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>看这篇文章：<strong><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">解读 java 并发队列 BlockingQueue</a></strong>，干货。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>生产者消费者模式：有了阻塞队列，我们实现生产者消费者模式只需要调用接口就行了，不用自己实现线程的阻塞和唤醒，也就是说阻塞队列接口的实现方式就是生产者消费者模式的实现。再之后会详细讲述生产者消费者模式</li>
<li>线程池：线程池的底层也是用到了阻塞队列，其实它的本质也是生产者消费者模式，只不过这里的资源是<strong>线程</strong></li>
<li>消息中间件：RabbitMQ等消息队列的底层数据结构就是用到了阻塞队列，因为它的模型也是生产者消费者模式。</li>
</ul>
<h2 id="6-各种锁"><a href="#6-各种锁" class="headerlink" title="6. 各种锁"></a>6. 各种锁</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁就是获取锁的顺序就是申请锁的顺序，即先来后到。非公平锁则不一定，即可以加塞，在多线程的情况下，可能会造成<strong>优先级反转和饥饿现象</strong>。在JAVA中，<strong>ReentrantLock、ReadWriteLock、Synchronized</strong>默认都是非公平模式。非公平锁的吞吐量比公平锁高，性能也好一些。</p>
<p>公平锁与非公平锁在实现机制上的具体区别就是：公平锁在获取锁之前会先判断等待队列是否为空或者自己位于队列首部，如果为true则可以继续获取锁，否则就入队等待。而非公平锁则直接去获取锁，这就导致，如果锁刚刚释放的时候来了一个线程获取非公平锁，而等待队列中的线程还没来得及去获取，等到它去获取的时候，这个锁以及被占了。我们分别看看ReentrantLock中的公平锁和非公平锁中的获取锁的代码：</p>
<p>首先是非公平锁，可以看到，<strong>获取锁的时候直接去获取的</strong>，<code>compareAndSetState(0, 1)</code> 修改锁的状态，修改成功则表示锁已经被释放了，然后把占有锁的线程改为本线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看公平锁，对比一下看到非公平锁可以说是非常暴力的去占有了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 状态为0说明锁已经释放了，就可以去试着获取锁了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 再尝试获取之前（即修改锁的状态）还调用了hasQueuedPredecessors()，这是公平锁实现的核心逻辑</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 这个是可重入锁的逻辑，如果此线程已经获取锁了，还可以获取锁（可能锁的不是同一个地方）</span></span><br><span class="line">        <span class="comment">// acquires变量就是这个锁被获取的次数了。</span></span><br><span class="line">        <span class="comment">// 再获取 +1 即可</span></span><br><span class="line">        <span class="comment">// 别的线程获取锁的时候也要等到获取的锁全部释放了才行</span></span><br><span class="line">        <span class="comment">// 因为调用的是 compareAndSetState(0, 1), 0是期望值，也就是acquires为0才行</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深入看看 <code>hasQueuedPredecessors()</code>，作用是判断此线程是否应该放入等待队列。 首先说明一下这个等待队列是个头节点不存元素的队列。<code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</code> 表示<strong>此队列不为空并且这个线程不在头节点处</strong>，就应该入等待队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁（又名递归锁）"><a href="#可重入锁（又名递归锁）" class="headerlink" title="可重入锁（又名递归锁）"></a>可重入锁（又名递归锁）</h3><p>可重入锁的意思就是，外层方法获得锁之后，进入内层方法调用的方法自动获得，并不会阻塞。直接点的意思就是，同一个线程，可以多次获得同一把可重入锁，写一个例子看看，再结合上一节公平锁中 <code>tryAcquire()</code> 中的注释，就能理解的比较清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 多线程共享变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doSomething();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>print()</code> 方法的同步块中，调用 <code>dosomething()</code> 方法时又获取了这把锁，这个时候这把锁还没有释放，也就是上一节中的代码中的 state 并不为 0，但由于是可重入锁，所以并不会阻塞，而是将 acquires 变量 +1。注意可重入锁的可重入性只针对本线程。</p>
<p>为什么要用到可重入锁呢？就是我们想锁的代码块只不想别的线程同时执行，但是本线程的同步块还是可以调用执行的。比如上述例子，<code>doSomething()</code> 方法在多线程下可能会出现并发问题，<code>print()</code> 同样，所以我们都得锁上，但是 <code>print()</code> 方法中调用了 <code>doSomething()</code> 方法，如果不可重入，这个线程就被自己锁死在这了。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>JDK1.6 对锁的实现引入了大量的优化，包括偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等。<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">具体介绍</a>，还有深入理解JVM一书。</p>
<p>首先先主要介绍一些自旋锁。简单一句就是，<strong>如果获取不到锁，此线程并不挂起，而是循环获取锁，一直到获取到为止。</strong>为什么要这样呢？锁对性能的消耗就在于线程挂起和唤起的上下文切换，操作系统要在核态和用户态之间切换，很费时。<strong>它的缺点就是在竞争很激烈的情况下会有很多线程一直循环，占用资源。</strong></p>
<p>自旋锁的应用就是 CAS 操作 + 循环，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;Thread&gt; atomicThread = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (atomicThread.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p><strong>独占锁</strong>就是同一时间只能有一个线程持有，ReentrantLock 和 Synchronized 都是独占锁。<strong>共享锁</strong>就是同一时间可以有多个线程持有。</p>
<p>ReentrantReadWriteLock为读写锁，对于读操作是共享锁，对于写操作是独占锁。这样可以做到<strong>读读操作不互斥</strong>，但是读写，写读和写写操作都是互斥的。提一下之前提到的 CopyOnWriteArrayList，对它的操作可以只做到写写互斥，其余三个操作不互斥。</p>
<p><code>ReentrantReadWriteLock</code> 分为 <code>writeLock</code> 和 <code>readLock</code> 两种锁，下面是读写锁的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            count ++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Main resource = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(resource::writeOperation, <span class="string">"t"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">110</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(resource::readOperation, <span class="string">"t"</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果运行的效果是：先每隔 一秒打印一次 <strong>ti</strong>，说明写写互斥（每隔1s打印），写读互斥（打印时不输出读操作的输出），如果把两个循环交换顺序，可以看到，程序先等一秒，然后一次性输出十次数据，接着再一秒一次打印 <strong>ti</strong>， 说明读读不互斥（一次性全输出），读写互斥（读操作的sleep 1s的过程中，并没有输出写操作的输出）。</p>
<h2 id="7-CountDownLatch-CyclicBarrier-Semaphore"><a href="#7-CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="7. CountDownLatch / CyclicBarrier / Semaphore"></a>7. CountDownLatch / CyclicBarrier / Semaphore</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>就是个计数器，要等计数器为 0 之后才能继续往下执行，方法就几个，用起来比较简单，直接看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(countDownLatch::countDown).start();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 会在这阻塞，直到计数变为0</span></span><br><span class="line">    countDownLatch.await(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>跟 CountDownLatch 相反，CyclicBarrier 设置一个屏障，当要求个数的线程到齐了才能执行，之前到的会一直阻塞在这。例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数中的 Runnable 会在阻塞了六个线程之后执行。</span></span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">6</span>, () -&gt; System.out.println(<span class="string">"来完了"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"来一个"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 会阻塞在这</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果把语句 System.out.println("来一个"); 放在这，会在 6s 之后跟参数中的Runnable一起执行。</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>在资源有多个的时候，可以用 Semaphore 来进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享资源有3个</span></span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();  <span class="comment">// 抢占资源, 还可以通过参数控制获取的资源数</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"抢到资源"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                semaphore.release(); <span class="comment">// 释放资源，可以通过参数控制释放的资源数</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Synchronized-与-Lock-的区别"><a href="#8-Synchronized-与-Lock-的区别" class="headerlink" title="8. Synchronized 与 Lock 的区别"></a>8. Synchronized 与 Lock 的区别</h2><ol>
<li><p>Synchronized 是属于虚拟机层面，Lock是属于api层面，前者是关键字，后者是java实现的类。也就是说前者是在<strong>JVM内部</strong>实现的，Lock是在<strong>语言层面</strong>实现的。JVM内部使用的是 monitorenter 和 monitorexit 指令实现，Lock基本的是用的 state 变量来判断是否被锁。</p>
</li>
<li><p>Synchronized 不用手动释放锁，代码执行完了自动释放，而Lock要手动释放，lock() 和 unlock() 方法必须配对使用。</p>
</li>
<li><p>Synchronized 不能中断，必须抛出异常或者代码执行完，</p>
<p>而 Lock 可以中断，这也是Lock的特点。1. 可以设置超时方法 <code>tryLock(long timeout, TimeUnit unit)</code>; 2. 上锁的时候可以上可中断锁 <code>lockInterruptibly()</code> ，线程阻塞在锁这的时候可以在其他线程中调用 <code>interrupter()</code> 方法中断，抛出 <code>InterruptedException</code> 异常以供处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"被中断了"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    Thread th = <span class="keyword">new</span> Thread(resource::method);</span><br><span class="line">    th.start();</span><br><span class="line">    Thread th1 = <span class="keyword">new</span> Thread(resource::method, <span class="string">"tttttt"</span>);</span><br><span class="line">    th1.start();</span><br><span class="line">    th1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Synchronized 是非公平锁，Lock默认是非公平锁，但是可以设置成公平锁。</p>
</li>
<li><p>Synchronized 唤醒线程时只能随机唤醒，Lock可以搭配Condition实现精准唤醒某个线程。<strong>通过声明多个 Condition 来实现，唤醒时唤醒阻塞在某个 Condition 上的线程。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> who = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (who != <span class="number">1</span>) </span><br><span class="line">                c1.await();</span><br><span class="line">            System.out.println(<span class="string">"11111111111111"</span>);</span><br><span class="line">            who = <span class="number">2</span>;</span><br><span class="line">            c2.signal(); <span class="comment">// 精准唤起阻塞在 print2 方法中的线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (who != <span class="number">2</span>)</span><br><span class="line">                c2.await();</span><br><span class="line">            System.out.println(<span class="string">"222222222222222"</span>);</span><br><span class="line">            who = <span class="number">1</span>;</span><br><span class="line">            c1.signal(); <span class="comment">// 精准唤起阻塞在print1中的线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::print1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::print2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="9-生产者消费者模式"><a href="#9-生产者消费者模式" class="headerlink" title="9. 生产者消费者模式"></a>9. 生产者消费者模式</h2><p>自己手撸一个简易版的生产者消费者模式，我们需要自己判断线程什么时候应该阻塞，要怎么阻塞，什么时候应该唤醒，应该怎么唤醒，这些需要用到 <code>ReentrantLock</code> 来加锁，还要用到 <code>Condition</code> 的 <code>await()</code> 和 <code>signal()</code> 方法来控制线程的阻塞和唤醒。</p>
<p>当有了阻塞队列之后，我们就不用自己控制这些了，使得开发更加便捷，但是通过自己实现简易版的生产者消费者模式我们可以了解到阻塞队列的原理，阻塞队列内部也是通过<code>ReentrantLock</code> 来加锁，用<code>Condition</code>来控制线程的阻塞和唤醒的。</p>
<h3 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt;= capacity) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"阻塞在这了"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"被唤醒了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产了一个资源"</span> + <span class="string">"  "</span> + count);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"阻塞在这了"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"被唤醒了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"消费了一个资源"</span> + <span class="string">"  "</span> + count);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Resource resource = <span class="keyword">new</span> Resource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::produce, <span class="string">"生产者t"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(resource::consume, <span class="string">"消费者t"</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程中的判断一定要用 <strong>while</strong> 判断，而不能只用 if 判断，因为 <strong>await 操作阻塞线程会释放锁</strong>，这样的话，可能会有多个线程阻塞着，调用 signalAll 唤醒所有阻塞线程的时候，它们没有判断就直接执行操作，比如第一个生产者生产了一个资源，紧接着其余四个生产者阻塞在这，当一个消费者消费之后，这四个生成着都会一个一个接着生产，这样就会超出capacity。</p>
<h3 id="阻塞队列版"><a href="#阻塞队列版" class="headerlink" title="阻塞队列版"></a>阻塞队列版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>; <span class="comment">// 是否生产的标志</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger data = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 资源数据</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">null</span>; <span class="comment">// 通过消息队列来实现生产者消费者模式</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        System.out.println(queue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> offerResult;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            <span class="comment">// 进队即表示生产, 两秒之后队列还是满的，就不等了</span></span><br><span class="line">            offerResult = queue.offer(data.incrementAndGet(), <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (offerResult) &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者 "</span> + Thread.currentThread().getName() + <span class="string">" 生产成功："</span> + data.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"生产者 "</span> + Thread.currentThread().getName() + <span class="string">" 等了2s队列仍为满，本次生产失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 1s后再生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"生产者被叫停了，停止生产"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer result;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = queue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者 "</span> + Thread.currentThread().getName() + <span class="string">" 等了2s队列任为空，停止消费"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"消费者 "</span> + Thread.currentThread().getName() + <span class="string">" 消费成功："</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"停止生产和消费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    MySource mySource = <span class="keyword">new</span> MySource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"生产者启动"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mySource.produce();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"prod"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者启动"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mySource.consume();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"cons"</span>).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    mySource.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用阻塞队列来实现生产者和消费者模式，最大的一个好处就是我们<strong>不用自己去管理线程的阻塞和唤醒</strong>。</p>
<h2 id="10-Callable"><a href="#10-Callable" class="headerlink" title="10. Callable"></a>10. Callable</h2><p><code>Callable</code> 和 <code>Runnable</code> 的主要区别就是 <code>Callable</code> <strong>有返回值，并且可以在发生错误时抛出异常</strong>，在需要有返回值或者需要在多线程环境下进行排错时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何使用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread1());        </span><br><span class="line"><span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure>

<p>为什么是这么用的呢，我们可以看到，<code>Thread</code> 类的构造函数中只有 <code>Runnable</code> ，没有 <code>Callable</code>，但是我们先看看下列的实现和继承关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在 <code>FutureTask</code> 中有一个成员变量为 <code>private Callable&lt;V&gt; callable;</code> ，也就是说，JDK对 <code>Runnable</code> 接口和 <code>Future</code>接口做了包装和实现，在调用的时候也能像 <code>Runnable</code>一样的去传参。而在调用 <code>run()</code> 方法的时候，实际上是调用了 <code>Callable</code> 的<code>call()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么要用 <code>Callable</code>呢，为什么有了 <code>Runnable</code> 还要用 <code>Callable</code> 呢？答案是异步，是减少阻塞，即主线程在执行到这个线程时，并不在这阻塞，而是继续往下执行，这个线程继续进行它的计算，在未来的某一时刻，我们在调用 <code>futureTaks.get()</code> 来获取结果，如果调用这个方法时，<strong>计算还没有完成，还是会阻塞</strong>，但是我们已经执行完我们想执行的操作啦，<strong>提高了并发，充分利用了CPU资源</strong>。如下代码看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 耗时计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Date begin = <span class="keyword">new</span> Date();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread1());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start(); <span class="comment">// 如果在此处阻塞进行线程中的耗时计算，理论上最后的输出为 3000以上。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"看看阻塞了没"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    Integer ele1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(futureTask.get() + ele1); <span class="comment">// 如果还没算完，仍然阻塞，但是上面三句语句已经执行了</span></span><br><span class="line">    Date end = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(end.getTime() - begin.getTime());  <span class="comment">// 输出为 2002，提高了并发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就又有一个疑问，就算是用 <code>Runnable</code> 执行，也是不回阻塞的呀？但是这里的情况是数据依赖的，我们的后续操作要用的数据，必须是计算完的结果，如果我们用 <code>Runnable</code>,  <strong>我们也必须控制线程的执行顺序，并且还要获取计算结果</strong>，是很麻烦的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="number">1</span>;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Date begin = <span class="keyword">new</span> Date();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"看看阻塞了没"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    Integer ele1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    thread.join(); <span class="comment">// 用它来控制数据依赖时线程的执行顺序</span></span><br><span class="line">    System.out.println(data + ele1);</span><br><span class="line">    Date end = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(end.getTime() - begin.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable</code> 还有很多优点，比如<strong>同一个 <code>Callable</code> 线程</strong>，多次调用 <code>start()</code> 方法时，<strong>只会调用一次</strong>，因为结果已经算出来了。<code>Callable</code> 还实现了  <code>Future</code> 接口，提供了 <code>cancel()</code> 、<code>isCancelled()</code> 等方法，使用起来更灵活强大。</p>
<h2 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h2><h3 id="线程池的特点和优势"><a href="#线程池的特点和优势" class="headerlink" title="线程池的特点和优势"></a>线程池的特点和优势</h3><p>线程池中的线程，需要时直接分配，而不是新创建一个，不需要时归还给线程池，而不需要真的销毁。其最大的特定就是：<strong>线程复用、控制最大并发数、管理线程</strong></p>
<ol>
<li>线程的创建和销毁是很耗时间的，线程复用即可通过<strong>重复利用线程来降低此消耗</strong>。</li>
<li><strong>提高响应速度</strong>，任务来了可以不用等线程创建的过程。</li>
<li>线程本身也要占据内存空间的，如果使用不当，可能会导致OOM异常。即使没有，大量的线程回收也会加重GC回收线程的压力，所以我们要用线程池来<strong>控制最大并发数</strong>。</li>
<li><strong>提高线程的可管理性</strong>，通过线程池可以对线程进行统一的<strong>分配，调优和监控</strong>。</li>
</ol>
<h3 id="常用的线程池及其创建方式"><a href="#常用的线程池及其创建方式" class="headerlink" title="常用的线程池及其创建方式"></a>常用的线程池及其创建方式</h3><p>先说一下各个类的继承和实现的关系。<code>ThreadPoolExecutor</code> 是线程池的一个实现类，它实现了 <code>ExecutorService</code> 接口。<code>Executors</code> 是一个工具类，<strong>用来创建线程池的</strong>， 主要有以下工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>newFixedThreadPool</code> 返回一个固定数量的线程池，当有空闲线程时，将新任务分配给它，<strong>如果没有空闲线程，将任务暂存进任务队列中。</strong></li>
<li><code>newSingleThreadExecutor</code> 返回只有一个线程的线程池，如果没有空闲线程，将任务暂存进任务队列，当有空闲队列，<strong>按入队的顺序处理</strong>（与使用的任务队列有关）</li>
<li><code>newCachedThreadPool</code> 返回一个按实际情况调整的线程池，如果没有空闲线程，则新建线程。</li>
<li><code>newSingleThreadScheduledExecutor()</code> 只有一个线程，可以指定在某个延迟时间后执行，或者周期性执行。</li>
<li><code>newScheduledThreadPool</code> 可以指定线程数量。</li>
</ol>
<p>以下一个示例展示了如何使用线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor-的七大参数"><a href="#ThreadPoolExecutor-的七大参数" class="headerlink" title="ThreadPoolExecutor 的七大参数"></a>ThreadPoolExecutor 的七大参数</h3><p>上述创建线程池方法的前三个，其底层都是通过 <code>new</code> 一个 <code>ThreadPoolExecutor</code> 对象来实现的，如果这三种线程池不能满足我们的需求，我们就需要自己来创建了，<code>ThreadPoolExecutor</code> 为我们提供了七个参数，以供我们自定义。<strong>在阿里编码规范中，也禁止我们用 Executors 来创建线程池，因为有弊端，前两个是无界队列，后一个线程数最大为Max，都可能导致资源耗尽。并且，用 <code>ThreadPoolExecutor</code> 来创建线程池，我们会更加了解线程池的各个特点，避免浪费资源。当面试官问我们用哪个 <code>Executors</code> 的方法来创建，答案是一个都不用。</strong></p>
<p>先看看定制好的三种线程池的参数分别为什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再一一讲解这些参数的含义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize：线程池中常驻的线程数量（可以用来工作的线程），当任务数超过这个数，任务会放到任务队列中。</li>
<li>maximumPoolSize：指定了线程池中最大的线程数量（任务量大于 corePoolSize时，可以再创建线程）</li>
<li>keepAliveTime：指定了多余空闲线程的存活时间，即超过 corePoolSize 的空闲线程，在多久之后会被销毁（在任务量降下来之后，之前创建的线程<strong>会慢慢销毁，节省资源</strong>）</li>
<li>unit：keepAliveTime的单位</li>
<li><strong>workQueue</strong>：任务队列，被提交但未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认</li>
<li><strong>handler</strong>：拒绝策略，表示当队列满了，并且<strong>工作线程</strong>大于等于 maximumPoolSize，如何拒绝任务。</li>
</ul>
<h3 id="各种阻塞队列的效果"><a href="#各种阻塞队列的效果" class="headerlink" title="各种阻塞队列的效果"></a>各种阻塞队列的效果</h3><ul>
<li><strong>SynchronousQueue</strong>：容量为0，提交的任务不会真实的保存，而总是将任务提交给线程执行，当没有空闲线程的时候，会创建新的线程来执行，如果线程数已经达到了 maximumPoolSize ，则会执行拒绝策略。</li>
<li><strong>ArrayBlockingQueue</strong>：<strong>有界队列</strong>，<strong>如果没有空闲线程（即工作线程数大于等于corePoolSize）</strong>，则会将任务暂存到此队列，如果队列满了，线程数小于 maximumPoolSize，则创建新的线程，否则，执行拒绝策略</li>
<li><strong>LinkedBlockingQueue</strong>：<strong>无界队列</strong>，<strong>如果没有空闲线程（即工作线程数大于等于corePoolSize）</strong>, 则会将任务暂存到此队列，队列不会满，所以线程池中的线程数不会大于 corePoolSize。使用无界队列要注意任务创建速度过快与处理速度时，内存资源耗尽。</li>
<li><strong>PriorityBlockingQueue</strong>：<strong>无界队列</strong>，区别在于，出队时是根据优先级来出队的。</li>
</ul>
<h3 id="线程池的底层原理"><a href="#线程池的底层原理" class="headerlink" title="线程池的底层原理"></a>线程池的底层原理</h3><p>流程如下：</p>
<ol>
<li>在创建了线程池之后，线程池等待任务的提交。</li>
<li>当调用 <code>executor()</code> 时，会做如下判断：<ol>
<li>正在执行的线程数小于 corePoolSize，分配空闲线程执行任务</li>
<li>正在执行的线程数大于等于 corePoolSize，任务进入等待队列</li>
<li>如果等待队列满了，并且正在执行的线程数小于 maximumPoolSize，创建新的线程执行任务。</li>
<li>如果等待队列满了，并且正在执行的线程数等于 maximumPoolSize，则执行拒绝策略</li>
</ol>
</li>
<li>当一个线程执行完一项任务，会从任务队列中取任务来执行。</li>
<li>当一个线程空闲时间超过 keepAliveTime 时，会进行判断：如果线程池中的线程（<strong>执行线程+空闲线程</strong>）数量大于 corePoolSize, 这个线程就会停掉，所以当任务量少下来之后，线程池中的线程数会慢慢回归到 corePoolSize。</li>
</ol>
<p>从 <code>excutor()</code> 的源码我们也大概能看出以上步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果执行线程小于 corePoolSize, 分配执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则加入等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 加入成功之后，线程池被 shutdown 了，就把这项任务移除了，移除成功之后再拒绝</span></span><br><span class="line">        <span class="comment">// 这部分不知为何这样设计，目前能理解步骤，但不知为何这样。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列满了，创建新线程进行执行，如果创建失败，说明执行线程达到了maximumPoolSize，则拒绝</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h3><ul>
<li>AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常，阻止系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行机制” 即只要线程池未关闭，则任务返回到<strong>调用者线程</strong>中，运行当前被丢弃的任务，例如我们在<strong>主线程中调用线程池的<code>execute()</code>，被拒绝的任务会在 主线程 中执行。</strong></li>
<li>DiscardOldestPolicy：丢弃等待最久的那个任务（即即将被执行的那个），相当于出队一次再入队一次。然后再次尝试提交当前任务。</li>
<li>DiscardPolicy：直接丢弃，不给予任何处理。</li>
</ul>
<h3 id="自定义线程池和拒绝策略"><a href="#自定义线程池和拒绝策略" class="headerlink" title="自定义线程池和拒绝策略"></a>自定义线程池和拒绝策略</h3><p>这部分，要了解 <code>ThreadPoolExecutor</code> 的七大参数，还要知道拒绝策略是如何自己实现的，上一节说到的四种拒绝策略都实现了 <code>RejectedExecutionHandler</code> 接口，此接口只有一个方法，<strong>我们重写一个类，实现此接口就可以了，因为参数都是接口，我们传入实现类即可，可扩展的精髓</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// r 是要执行的任务，executor 是执行任务的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">6L</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    (r, executor) -&gt; System.out.println(<span class="string">"丢弃了"</span> + r.toString())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的线程数量的确定"><a href="#线程池的线程数量的确定" class="headerlink" title="线程池的线程数量的确定"></a>线程池的线程数量的确定</h3><p>关于这个问题，我们要根据任务是 CPU 密集型还是 IO 密集型来分。</p>
<ol>
<li>CPU 密集型，持续性的占用CPU，所以我们要减少线程上下文切换，maximumPoolSize = cpu线程数 + 1</li>
<li>IO 密集型，并不是持续占用CPU，可以同时多执行点任务<ol>
<li>maximumPoolSize = cpu线程数 * 2</li>
<li>maximumPoolSize = cpu线程数  / (1 - 阻塞系数) ，其中阻塞系数在 0.8 到 0.9 之间（其中一种方案）</li>
</ol>
</li>
</ol>
<p>还有一种方案是《实战Java高并发程序设计》书中所给的：<strong>Nthreads = Ncpu * Ucpu * (1 + W/C)</strong></p>
<p>其中 <strong>Ncpu</strong> 为cpu的线程数，<strong>Ucpu</strong> 为期望cpu的使用率(0&lt;=Ucpu&lt;=1)，<strong>W/C</strong>为等待时间与计算时间的比率。</p>
<h1 id="面试题目总结"><a href="#面试题目总结" class="headerlink" title="面试题目总结"></a>面试题目总结</h1><h2 id="1-HashSet的底层是什么？（答HashMap，会问为什么hashSet-add-“a”-只有一个参数）"><a href="#1-HashSet的底层是什么？（答HashMap，会问为什么hashSet-add-“a”-只有一个参数）" class="headerlink" title="1. HashSet的底层是什么？（答HashMap，会问为什么hashSet.add(“a”)只有一个参数）"></a>1. HashSet的底层是什么？（答HashMap，会问为什么hashSet.add(“a”)只有一个参数）</h2><p>要看仔细底层源码，HashSet的底层肯定是HashMap，那么添加时的Key和Value是怎么处理的呢，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，确实是HashSet。再看add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，map的key是要插入的值，map的value统一是一个空对象。同时根据map的key不能重复就可以实现set元素不能重复的功能了。</p>
<p>那么如何得到一个值呢？如果插入到一个节点的值只有value，不久获取不到key了，那set的功能也失效了，看源码可以知道，Node有四个变量，其中就有 key 和 value，也就是说都节点把信息都保存了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-死锁的编码的排查"><a href="#2-死锁的编码的排查" class="headerlink" title="2. 死锁的编码的排查"></a>2. 死锁的编码的排查</h2><p>自己写一个Demo模拟死锁，首先我们要知道死锁是怎么发生，即两个或两个以上的线程同时争抢资源造成的互相等待的局面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得了锁"</span> + lockA + <span class="string">", 尝试获得锁"</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得了锁"</span> + lockB + <span class="string">", 尝试获得锁"</span> + lockA);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">"aaaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MySource mySource = <span class="keyword">new</span> MySource(<span class="string">"lockA"</span>, <span class="string">"lockB"</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(mySource::getLock1, <span class="string">"thread1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(mySource::getLock2, <span class="string">"thread2"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么怎么证明是死锁呢？这个程序还好说，因为是我们自己写的，我们知道是死锁，但是在现实中，程序卡住不走了，我们怎么知道是不是死锁造成的呢？有可能是死循环等等。我们用 jps 和 jstack 来进行排查。</p>
<p><code>jps</code> 命令展示正在执行的java<strong>进程</strong>机器id。<code>jstack</code> 命令是堆栈跟踪工具，主要用来查看java线程的<strong>调用堆栈和状态</strong>，可以用来分析线程问题，如死锁。</p>
<p>首先用jps命令找到此进程的编号，然后执行命令 <code>jstack 编号</code> 就可以看到是否有死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread2&quot;:</span><br><span class="line">        at Main$MySource.getLock2(Main.java:28)</span><br><span class="line">        - waiting to lock &lt;0x00000007812fc5c0&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000007812fc5f8&gt; (a java.lang.String)</span><br><span class="line">        at Main$$Lambda$2/1831932724.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">        at Main$MySource.getLock1(Main.java:19)</span><br><span class="line">        - waiting to lock &lt;0x00000007812fc5f8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000007812fc5c0&gt; (a java.lang.String)</span><br><span class="line">        at Main$$Lambda$1/1096979270.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>jstack</code> 能够帮我们找出死锁，然后我们在回到程序中进行改善即可。</p>
<ol>
<li>SpringCloud微服务的相关问题</li>
<li>jdk1.7和jdk1.8的hashmap有什么不同</li>
<li>JAVA各种集合以及区别</li>
<li>多线程的线程池是如何工作的，底层源码和原理</li>
<li>本地线程threadlocal的实现原理</li>
<li>Springboot 和 SpringMVC的区别</li>
<li>JVM的三种回收方式有什么不同，CMS和G1有什么区别（即回收机制和回收器）</li>
<li>数据库优化时候索引有哪几种索引，如何选择？</li>
<li>多人同时抢购一个库存的商品应该怎么处理（分布式事务）</li>
<li>如何处理高并发，也就是请求数量大于本地线程数量的时候不出错</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/12/19/单例类/">单例类</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://baoyixiang.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/19/知识总结/">知识总结（持续更新。。。）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/单例类/">单例类</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/30/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">一路向前.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>